From 6324043ba3e203b174c94c6dd2d9922007cf89e1 Mon Sep 17 00:00:00 2001
From: Pedro Luis Rodríguez González <pl.rguez@gmail.com>
Date: 11 ago. 2020 19:49:18

Patch #001 for RG350/GCW ZERO and RetroFW 1 & 2


diff --git a/.gitignore b/.gitignore
index a60502f..0bff2a4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -105,3 +105,11 @@
 /z80/z80_ddfd.c
 /z80/z80_ddfdcb.c
 /z80/z80_ed.c
+/nbproject/
+/Platform/roms/*.rom
+/Platform/GCW0/build/
+/Platform/RETROFW2.0/build/
+/Platform/RETROFW1.0/build/
+/Platform/GCW0/gdbinit
+/Platform/RETROFW1.0/gdbinit
+/Platform/RETROFW2.0/gdbinit
diff --git a/Makefile.am b/Makefile.am
index 960f13c..2126a2b 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -146,7 +146,20 @@
 	     menu_data.pl \
 	     settings.dat \
 	     settings.pl \
-	     settings-header.pl
+	     settings-header.pl \
+	     Platform/readme.txt \
+	     Platform/roms/read.me \
+	     Platform/GCW0/Makefile \
+	     Platform/GCW0/default.gcw0.desktop \
+	     Platform/GCW0/system.gcw0.desktop \
+	     Platform/RETROFW2.0/Makefile \
+	     Platform/RETROFW2.0/default.retrofw.desktop \
+	     Platform/RETROFW2.0/system.retrofw.desktop \
+	     Platform/RETROFW1.0/Makefile \
+	     Platform/RETROFW1.0/conffiles \
+	     Platform/RETROFW1.0/control \
+	     Platform/RETROFW1.0/fuse.lnk \
+	     Platform/RETROFW1.0/postinst
 
 CLEANFILES = options.h \
 	     settings.c \
diff --git a/Platform/GCW0/Makefile b/Platform/GCW0/Makefile
new file mode 100644
index 0000000..c79a57f
--- /dev/null
+++ b/Platform/GCW0/Makefile
@@ -0,0 +1,65 @@
+BASEDIR = ../..
+BUILDDIR = build
+TARGET = fuse-gcw0.opk
+BUILD = fuse-gcw0
+ICON = fuse.png
+README = ../readme.txt
+UIDIR = $(BUILDDIR)/ui
+FONT = fuse.font
+LIBDIR = $(BUILDDIR)/lib
+LIBFILES = $(LIBDIR)/cassette.bmp $(LIBDIR)/microdrive.bmp $(LIBDIR)/plus3disk.bmp $(LIBDIR)/keyboard.png $(LIBDIR)/keyboard.scr
+ROMSDIR = $(BUILDDIR)/roms
+BASEROMSDIR = $(BASEDIR)/roms
+EXTRAROMSDIR = ../roms
+ROMS = $(ROMSDIR)/*.rom
+
+all: buildfuse opk
+
+$(TARGET): $(BUILD) $(ICON) $(FONT) $(ROMS) $(LIBFILES) $(README)
+	@mksquashfs \
+	default.gcw0.desktop \
+	system.gcw0.desktop \
+	$(README) \
+	$(BUILDDIR)/$(BUILD) \
+	$(ROMSDIR) \
+	$(BUILDDIR)/$(ICON) \
+	$(UIDIR) \
+	$(LIBDIR) \
+        $(BUILDDIR)/$(TARGET) \
+	-all-root -noappend -no-exports -no-xattrs
+
+$(BUILD): $(BASEDIR)/fuse
+	cp $^ $(BUILDDIR)/$@
+
+$(ICON): $(BASEDIR)/data/icons/32x32/fuse.png
+	cp $^ $(BUILDDIR)/$@
+
+$(ROMS): $(BASEDIR)/roms/*.rom
+	mkdir -p $(ROMSDIR)
+	cp $(BASEROMSDIR)/*.rom $(ROMSDIR)
+	-cp $(EXTRAROMSDIR)/*.rom $(ROMSDIR)
+
+$(FONT): $(BASEDIR)/ui/widget/fuse.font
+	mkdir -p $(UIDIR)/widget
+	cp $^ $(UIDIR)/widget/$@
+
+$(LIBFILES): libfiles
+
+libfiles: $(BASEDIR)/lib/cassette.bmp $(BASEDIR)/lib/microdrive.bmp $(BASEDIR)/lib/plus3disk.bmp $(BASEDIR)/lib/keyboard.png $(BASEDIR)/lib/keyboard.scr
+	mkdir -p $(LIBDIR)
+	cp $^ $(LIBDIR)
+
+opk: $(TARGET)
+
+buildfuse:
+	cd $(BASEDIR) && $(MAKE)
+	mkdir -p $(BUILDDIR)
+
+
+.PHONY: clean deploy debug all libfiles
+clean:
+	cd $(BASEDIR) && $(MAKE) clean
+	rm -rf $(BUILDDIR)
+
+deploy: $(BUILDDIR)/$(TARGET)
+	scp $^ root@10.1.1.2:/media/sdcard/apps/
diff --git a/Platform/GCW0/default.gcw0.desktop b/Platform/GCW0/default.gcw0.desktop
new file mode 100644
index 0000000..01178a4
--- /dev/null
+++ b/Platform/GCW0/default.gcw0.desktop
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Name=Fuse 1.5.7
+Comment=Fuse ZX Spectrum emulator 1.5.7
+Exec=fuse-gcw0 %f
+Icon=fuse
+Type=Application
+Categories=emulators;
+MimeType=application/zx-snapshot;application/zx-disk;application/zx-tape;
+X-OD-NeedsDownscaling=true
+X-OD-Manual=readme.txt
diff --git a/Platform/GCW0/system.gcw0.desktop b/Platform/GCW0/system.gcw0.desktop
new file mode 100644
index 0000000..d6ddfda
--- /dev/null
+++ b/Platform/GCW0/system.gcw0.desktop
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Name=Fuse 1.5.7
+Comment=Fuse ZX Spectrum emulator 1.5.7 (no file selector)
+Exec=fuse-gcw0
+Icon=fuse
+Type=Application
+Categories=emulators;
+MimeType=application/zx-snapshot;application/zx-disk;application/zx-tape;
+X-OD-NeedsDownscaling=true
+X-OD-Manual=readme.txt
diff --git a/Platform/RETROFW1.0/Makefile b/Platform/RETROFW1.0/Makefile
new file mode 100644
index 0000000..7d363bb
--- /dev/null
+++ b/Platform/RETROFW1.0/Makefile
@@ -0,0 +1,69 @@
+BASEDIR = ../..
+BUILDDIR = build
+TARGET = fuse.ipk
+BUILD = fuse-retrofw
+ICON = fuse.png
+README = ../readme.txt
+UIDIR = $(BUILDDIR)/ui
+FONT = fuse.font
+LIBDIR = $(BUILDDIR)/lib
+LIBFILES = $(LIBDIR)/cassette.bmp $(LIBDIR)/microdrive.bmp $(LIBDIR)/plus3disk.bmp $(LIBDIR)/keyboard.png $(LIBDIR)/keyboard.scr
+ROMSDIR = $(BUILDDIR)/roms
+BASEROMSDIR = $(BASEDIR)/roms
+EXTRAROMSDIR = ../roms
+ROMS = $(ROMSDIR)/*.rom
+
+all: buildfuse ipk
+
+$(TARGET): $(BUILD) $(ICON) $(FONT) $(ROMS) $(LIBFILES) $(README)
+	@rm -rf /tmp/.fuse-ipk/ && mkdir -p /tmp/.fuse-ipk/root/home/retrofw/emus/fuse /tmp/.fuse-ipk/root/home/retrofw/apps/gmenu2x/sections/emulators
+	@cp -r $(BUILDDIR)/* $(README) /tmp/.fuse-ipk/root/home/retrofw/emus/fuse
+	@cp fuse.lnk /tmp/.fuse-ipk/root/home/retrofw/apps/gmenu2x/sections/emulators
+	@sed "s/^Version:.*/Version: $$(date +%Y%m%d)/" control > /tmp/.fuse-ipk/control
+	@cp conffiles postinst /tmp/.fuse-ipk/
+	@tar --owner=0 --group=0 -czvf /tmp/.fuse-ipk/control.tar.gz -C /tmp/.fuse-ipk/ control conffiles
+	@tar --owner=0 --group=0 -czvf /tmp/.fuse-ipk/data.tar.gz -C /tmp/.fuse-ipk/root/ .
+	@echo 2.0 > /tmp/.fuse-ipk/debian-binary
+	@ar r $(BUILDDIR)/$(TARGET) /tmp/.fuse-ipk/control.tar.gz /tmp/.fuse-ipk/data.tar.gz /tmp/.fuse-ipk/debian-binary
+
+$(BUILD): $(BASEDIR)/fuse
+	cp $^ $(BUILDDIR)/$@
+
+$(ICON): $(BASEDIR)/data/icons/32x32/fuse.png
+	cp $^ $(BUILDDIR)/$@
+
+$(ROMS): $(BASEDIR)/roms/*.rom
+	mkdir -p $(ROMSDIR)
+	cp $(BASEROMSDIR)/*.rom $(ROMSDIR)
+	-cp $(EXTRAROMSDIR)/*.rom $(ROMSDIR)
+
+$(FONT): $(BASEDIR)/ui/widget/fuse.font
+	mkdir -p $(UIDIR)/widget
+	cp $^ $(UIDIR)/widget/$@
+
+$(LIBFILES): libfiles
+
+libfiles: $(BASEDIR)/lib/cassette.bmp $(BASEDIR)/lib/microdrive.bmp $(BASEDIR)/lib/plus3disk.bmp $(BASEDIR)/lib/keyboard.png $(BASEDIR)/lib/keyboard.scr
+	mkdir -p $(LIBDIR)
+	cp $^ $(LIBDIR)
+
+ipk: $(TARGET)
+
+buildfuse:
+	cd $(BASEDIR) && $(MAKE)
+	mkdir -p $(BUILDDIR)
+
+
+.PHONY: clean deploy debug all libfiles
+clean:
+	cd $(BASEDIR) && $(MAKE) clean
+	rm -rf $(BUILDDIR)
+
+deploy: $(BUILDDIR)/$(TARGET)
+	echo -e "user root\n"\
+	        "cd /media/mmcblk1p1/apps\n"\
+	        "lcd $(BUILDDIR)\n"\
+	        "put $(TARGET)\n"\
+	        "bye\n" > deploy_fuse.ftp
+	ftp -inv 169.254.1.1 < deploy_fuse.ftp
+	rm deploy_fuse.ftp
\ No newline at end of file
diff --git a/Platform/RETROFW1.0/conffiles b/Platform/RETROFW1.0/conffiles
new file mode 100644
index 0000000..fe4cd92
--- /dev/null
+++ b/Platform/RETROFW1.0/conffiles
@@ -0,0 +1 @@
+/home/retrofw/apps/gmenu2x/sections/emulators/fuse.lnk
diff --git a/Platform/RETROFW1.0/control b/Platform/RETROFW1.0/control
new file mode 100644
index 0000000..a34c3d8
--- /dev/null
+++ b/Platform/RETROFW1.0/control
@@ -0,0 +1,10 @@
+Package: Fuse 1.5.7
+Version:
+Description: RetroFW 1 port of Fuse ZX Spectrum emulator 1.5.7
+Section: emus
+Priority: optional
+Maintainer: plrguez
+Architecture: mipsel
+Homepage: https://github.com/plrguez/fuse-rg350
+Depends:
+Source: https://github.com/plrguez/fuse-rg350
diff --git a/Platform/RETROFW1.0/fuse.lnk b/Platform/RETROFW1.0/fuse.lnk
new file mode 100644
index 0000000..e56de74
--- /dev/null
+++ b/Platform/RETROFW1.0/fuse.lnk
@@ -0,0 +1,5 @@
+title=Fuse 1.5.7
+description=Fuse 1.5.7 ZX Spectrum emulator
+exec=/home/retrofw/emus/fuse/fuse-retrofw
+selectordir=/home/retrofw/roms/zxspectrum
+clock=600
diff --git a/Platform/RETROFW1.0/postinst b/Platform/RETROFW1.0/postinst
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/Platform/RETROFW1.0/postinst
diff --git a/Platform/RETROFW2.0/Makefile b/Platform/RETROFW2.0/Makefile
new file mode 100644
index 0000000..3838978
--- /dev/null
+++ b/Platform/RETROFW2.0/Makefile
@@ -0,0 +1,71 @@
+BASEDIR = ../..
+BUILDDIR = build
+TARGET = fuse-retrofw.opk
+BUILD = fuse-retrofw
+ICON = fuse.png
+README = ../readme.txt
+UIDIR = $(BUILDDIR)/ui
+FONT = fuse.font
+LIBDIR = $(BUILDDIR)/lib
+LIBFILES = $(LIBDIR)/cassette.bmp $(LIBDIR)/microdrive.bmp $(LIBDIR)/plus3disk.bmp $(LIBDIR)/keyboard.png $(LIBDIR)/keyboard.scr
+ROMSDIR = $(BUILDDIR)/roms
+BASEROMSDIR = $(BASEDIR)/roms
+EXTRAROMSDIR = ../roms
+ROMS = $(ROMSDIR)/*.rom
+
+all: buildfuse opk
+
+$(TARGET): $(BUILD) $(ICON) $(FONT) $(ROMS) $(LIBFILES) $(README)
+	@mksquashfs \
+	default.retrofw.desktop \
+	system.retrofw.desktop \
+	$(README) \
+	$(BUILDDIR)/$(BUILD) \
+	$(ROMSDIR) \
+	$(BUILDDIR)/$(ICON) \
+	$(UIDIR) \
+	$(LIBDIR) \
+        $(BUILDDIR)/$(TARGET) \
+	-all-root -noappend -no-exports -no-xattrs
+
+$(BUILD): $(BASEDIR)/fuse
+	cp $^ $(BUILDDIR)/$@
+
+$(ICON): $(BASEDIR)/data/icons/32x32/fuse.png
+	cp $^ $(BUILDDIR)/$@
+
+$(ROMS): $(BASEDIR)/roms/*.rom
+	mkdir -p $(ROMSDIR)
+	cp $(BASEROMSDIR)/*.rom $(ROMSDIR)
+	-cp $(EXTRAROMSDIR)/*.rom $(ROMSDIR)
+
+$(FONT): $(BASEDIR)/ui/widget/fuse.font
+	mkdir -p $(UIDIR)/widget
+	cp $^ $(UIDIR)/widget/$@
+
+$(LIBFILES): libfiles
+
+libfiles: $(BASEDIR)/lib/cassette.bmp $(BASEDIR)/lib/microdrive.bmp $(BASEDIR)/lib/plus3disk.bmp $(BASEDIR)/lib/keyboard.png $(BASEDIR)/lib/keyboard.scr
+	mkdir -p $(LIBDIR)
+	cp $^ $(LIBDIR)
+
+opk: $(TARGET)
+
+buildfuse:
+	cd $(BASEDIR) && $(MAKE)
+	mkdir -p $(BUILDDIR)
+
+
+.PHONY: clean deploy debug all libfiles
+clean:
+	cd $(BASEDIR) && $(MAKE) clean
+	rm -rf $(BUILDDIR)
+
+deploy: $(BUILDDIR)/$(TARGET)
+	echo -e "user root\n"\
+	        "cd /media/mmcblk1p1/apps\n"\
+	        "lcd $(BUILDDIR)\n"\
+	        "put $(TARGET)\n"\
+	        "bye\n" > deploy_fuse.ftp
+	ftp -inv 169.254.1.1 < deploy_fuse.ftp
+	rm deploy_fuse.ftp
diff --git a/Platform/RETROFW2.0/default.retrofw.desktop b/Platform/RETROFW2.0/default.retrofw.desktop
new file mode 100644
index 0000000..f3d1aa6
--- /dev/null
+++ b/Platform/RETROFW2.0/default.retrofw.desktop
@@ -0,0 +1,8 @@
+[Desktop Entry]
+Name=Fuse 1.5.7
+Comment=Fuse ZX Spectrum emulator 1.5.7
+Exec=fuse-retrofw %f
+Icon=fuse
+Type=Application
+Categories=emulators;
+X-OD-Manual=readme.txt
diff --git a/Platform/RETROFW2.0/system.retrofw.desktop b/Platform/RETROFW2.0/system.retrofw.desktop
new file mode 100644
index 0000000..297c163
--- /dev/null
+++ b/Platform/RETROFW2.0/system.retrofw.desktop
@@ -0,0 +1,8 @@
+[Desktop Entry]
+Name=Fuse 1.5.7
+Comment=Fuse ZX Spectrum emulator 1.5.7 (no file selector)
+Exec=fuse-retrofw
+Icon=fuse
+Type=Application
+Categories=emulators.systems;
+X-OD-Manual=readme.txt
diff --git a/Platform/readme.txt b/Platform/readme.txt
new file mode 100644
index 0000000..fd7c692
--- /dev/null
+++ b/Platform/readme.txt
@@ -0,0 +1,3828 @@
+Using the Fuse emulator
+=======================
+
+This port port of Fuse it's in alpha stage.
+
+At the end of this doc is the man page of Fuse 1.5.7 for reference.
+
+------------------------
+### Opening the Menu ###
+------------------------
+You can open the menu with the `Power` or `Select` button.
+
+The `Select` button can be mapped to joystick or keyboard. In that case you can use the `Power` button for accessing the menu.
+
+---------------------
+### Save settings ###
+---------------------
+By default the emulator don't save settings changes.
+
+You can save settings at any time with `Menu -> Options -> Save`.
+
+Also you can activate Auto-save setting to save settings when you exit the emulator with `Menu -> File -> Exit`. To activate it access to `Menu -> Options -> General` then navigate to the option **Auto-save settings**, check it with the `X` Button and finally accept the form with the `A` Button. Yo should exit from the emulator o use the Save option to save it.
+
+The options are saved to **.fuserc** file at home directory. If some option change prevent to open the emulator yo can delete thid file and try again.
+
+------------------------
+### Virtual Keyboard ###
+------------------------
+Press the `Start` button to open a Virtual Keyboard when you are at emulator.
+
+The keys in the virtual keyboard correspond to ZX Spectrum keys and it send to emulator as if you are using a real ZX Spectrum keyboard.
+
+    `Cursor`
+    Move to select keys
+
+    `A`
+    Press key selected at keyboard
+
+    `B`
+    Lock key. It's marked in blue.
+    For use in combinatios of Caps Shift or Symbol Shift with other key.
+    They are used when press the `A` button over a Key. |For example: Lock key over "SS" and then press `A` Button over letter "P" to obtain character "
+
+    `X`
+    Press continously a key. It's marked in Red.
+
+    `Y`
+    Clean locked and continous pressed keys.
+
+    `Start`
+    Close Virtual Keyboard
+
+    `L1`, `R1`
+    Change the Virtual Keyboard position. There are 4 positions.
+
+-------------------------------------
+### Buttons at different contexts ###
+-------------------------------------
+
+=>Some machines don't have Sticks or `L2`, `R2` buttons.
+
+Buttons in emulator:
+--------------------
+    `Cursor`, `Left Stick`
+    Shift cursor ZX Spectrum keys (5, 6, 7, 8).
+    This is modified by the setting: "Use shift with arrow keys" by default On
+
+    `A`, `B`
+    Nothing
+
+    `Y`
+    CAPS Shift key
+
+    `X`
+    Space Key
+
+    `Select`, `Power`
+    Open general menu
+
+    `Start`
+    Open the virtual keyboard
+
+    `L1`
+    Open File selector dialog
+
+    `R1`
+    Open General options dialog
+
+    `Right Stick`
+    On RG350 models you can activate Mouse with `Power`+`B` combo and use to emulate Kempston mouse
+
+    `L2`
+    Left click with mouse emulation active
+
+    `R2`
+    Right click with mouse emulation active
+
+
+Buttons in Menu and Forms:
+--------------------------
+    `Cursor`, `Left Stick`
+    Move
+
+    `A`, `Start`
+    Select the option or accept the options at form
+
+    `B`, `Select`
+    Cancel and go back to previous menu or the emulator
+
+    `X`
+    Mark/Unmark a check option. For example "Auto-save settings"
+    Open dialog for choose an option. For example at Sound options -> AY stereo separation
+
+    `Y`
+    Nothing
+
+    `L1`
+    Go to the first option in menu
+
+    `R1`
+    Go to the last option in menu
+
+    `L2`
+    Go to the first entry in File selector
+
+    `R2`
+    Go to the last entry in File selector
+
+    `L2`, `R3`
+    Nothing
+
+    `Right Stick`
+    Nothing
+
+    `Power`
+    Cancel and exit completely from menu to the emulator
+
+#### Forms ####
+---------------
+Some menu options open a form with options to mark or choose some option from a list.
+General, Media and Sound are some forms.
+
+=>¡¡The forms must be accepted to persist the selected options!!
+  To accept it you must use the `A` or `Start` buttons.
+  The `B`, `Select` or `Power` buttons cancel it and the changes are lost.
+
+#### Virtual keyboard in menu ####
+----------------------------------
+Some other options from menu will open a virtual keyboard.
+
+This keyboard is very limited, it is don't showed at all possible options and it is not adapted to each context.
+
+Examples where the vistual keyboard it's appearing are: Enter name at Save Snapshot, Debugger, Change Emulation Speed or Frame rate.
+
+    `Cursor`
+    Move to select the keyboard keys
+
+    `A`
+    Press the actual selected key
+
+    `X`
+    Change the keyboard mode (Upper/Lower case and some other characters)
+
+    `Y`
+    Delete previous character
+
+    `B`
+    Cancel the form or option and exit
+
+    Accept forms
+    Select **En** at virtual Keyboard and press the `A` button to accept the form and exit
+
+For "enter the name" dialogs at save options the last loaded file name, without the extension, is proposed.
+
+------------------------------------------------
+### Mapping buttons to Joysticks or Keyboard ###
+------------------------------------------------
+You can map Joysticks or Spectrum key to buttons at `Menu -> Options -> Joysticks`
+
+There are three options but the relevant ones are the next:
+
+---- GCW0 Joystick 1... ----
+----------------------------
+This option allow to emulate a ZX Spectrum joystick. Also allow to map additional buttons to ZX Spectrum keyboard keys.
+
+It have two options:
+
+- **Type**:
+  ---------
+  This allow to choose the Joystick to emulate or None. Default is None.
+
+  Some type of Joysticks may require other emulators options active.
+  For example Kempston joystick need to be activated at `Menu --> Options --> Peripherals --> General` then check Kempston joystick and accept the form with `A` button.
+
+- **Button mapping**:
+  -------------------
+  Map the console buttons to Joystick fire, ZX Spectrum keys or to Nothing. By default all buttons are mapped to Joystick fire.
+
+  When you choose any Type other than **None** some buttons lost their general mapping if they was mapped at here. For example `Select`, `Start`, `L1` and `R1` buttons.
+  If you have mapped the `Select` button you can access to the Menu with `Power` button.
+
+---- GCW0 Keyboard... ----
+--------------------------
+This option allow to map console buttons to ZX Spectrum keyboard keys.
+
+It have two options:
+
+- **Type**:
+  ---------
+  Choose Activate option or None. Default is None.
+
+- **Button mapping**:
+  -------------------
+  Map buttons to ZX Spectrum keys or Nothing. By default all buttons are mapped to Nothing.
+
+  Again, yo can loose some button fucionality at emulator if they are mapped here.
+
+
+When both two are activated at once only the "GCW0 Joystick 1" will work.
+
+----------------------
+### Kempston mouse ###
+----------------------
+At RG350 models with right stick you can emulate Kempston mouse with the right stick and `L2`, `R2` buttons.
+This feature is not part of the port this is a standard feature of Fuse in combination with RG350 firmware capability of emulating mouse.
+
+You must activate it in the peripherals (`Menu -> Options -> Peripherals -> General`) and use the RG350 combo `Power` + `B` to activate mouse.
+
+---------------------
+### Triple Buffer ###
+---------------------
+There is an experimental implementation for triple buffer. It can be activated at General options.
+In general I believe that is not needed, but I've seen diference activating it running some demos on Pentagon's models as "mescaline synesthesia by deMarche".
+It affect to the speed.
+
+If tripple buffer is activated ther will be an [B] at status line.
+
+Bug: With the triple buffer there are some times when their deactivation make the screen freeze or go to black but the emulator is up and running... probably motivated by some mistake I've done at code.
+
+Also you can activate/deactivate triple buffer with this button combo: L1 + R1 + X
+
+---------------------
+### Media options ###
+---------------------
+
+If you have problems loading some programs take into account the compatibility with the diferent systems. There are programs than not load or hang in models like +2A or +3.
+In internet there are info about this and fixes for diferent models.
+
+Also take into account than some options in Media options can affect as "Accelerate loaders".
+
+------------
+### ROMs ###
+------------
+Fuse provide some roms for systems and peripherals. See int the source directory fuse/roms/README.copyright file for details.
+
+You can assign aditional roms from the emulator:
+
+- Open menu with `Select` or `Power` button. Then navigate from Menu --> Options --> Select Roms --> Machine ROMs or Peripheral ROMs
+- With the virtual keyboard select the key corresponding to the ROM to change. This open a file selector.
+- At file selector use the `cursor` keys to navigate to folder with your roms, select the needed rom and press the `A` Button to confirm selection.
+- Repeat until all the needed ROMs are selected. Then accept the selections choosing the **Enter
+
+Also you can put them at next directories:
+
+    For RG350 /media/data/local/home/.fuse/roms
+    For RetroFW /home/retrofw/.fuse/roms
+
+The emulator will not create the directories so you must create them manually.
+
+Also the ipk version will be installed at folder /home/retrofw/emus/fuse. You can put aditional roms at /home/retrofw/emus/fuse/romsfolder.
+
+Included with fuse:
+
+    48k
+    128k
+    +2
+    +2A
+    +3
+    +3e
+    Spectrum SE
+    Timex TC2048, TC2068 and TS2068
+    DISCiPLE and +D
+    SpeccyBoot
+
+These are not included:
+
+    Pentagon 128k, 512k and 1024k
+    Scorpion ZS 256
+    Interface 1
+    Beta 128
+    Didaktik 80
+    Multiface One, 128, 3
+    Opus Discovery
+    uSource
+
+And the default file names expected for some of the not included:
+
+    128p-0.rom
+    128p-1.rom
+    256s-0.rom
+    256s-1.rom
+    256s-2.rom
+    256s-3.rom
+    didaktik80.rom
+    gluck.rom
+    if1-2.rom
+    mf1.rom
+    mf128.rom
+    mf3.rom
+    opus.rom
+    trdos.rom
+    usource.rom
+
+================================================================================
+
+fuse(1)                            Emulators                           fuse(1)
+
+
+
+NAME
+       fuse -- Sinclair ZX Spectrum emulator
+
+SYNOPSIS
+       fuse [options]
+
+DESCRIPTION
+       Fuse  is  a  Sinclair  ZX Spectrum emulator. It supports several models
+       (including the 128), with quite faithful emulation of the  display  and
+       sound.
+
+       The emulator can load any of the formats supported by libspectrum(3) --
+       this includes Z80, SNA and SZX snapshots, and PZX, TAP and TZX virtual-
+       tape  files.  Saving to SZX, Z80 and SNA snapshots and TZX and TAP tape
+       files is supported. The SLT extension to the Z80 format is partly  sup-
+       ported  (enough for multi-load games); however, loading of the old DAT-
+       file variant is not.
+
+       DSK, UDI, FDI, TD0, MGT, IMG, D40, D80, SAD,  TRD,  SCL  and  OPD  disk
+       images are supported when a disk interface is being emulated, including
+       the integrated disk drives on +3, Pentagon or Scorpion machines as well
+       as  the  +D,  DISCiPLE, Opus Discovery, Beta 128 and Didaktik 80 inter-
+       faces. DCK cartridge images are supported when emulating  a  Timex 2068
+       variant. Interface 2 ROM cartridges are also supported.
+
+       Finally,  there  is  also support for reading and writing the RZX input
+       recording format.
+
+       See the COMPRESSED FILES section for  details  on  reading  files  com-
+       pressed with bzip2(3), gzip(3) or zip(3).
+
+OPTIONS
+       --accelerate-loader
+              Specify  whether  Fuse should attempt to accelerate tape loaders
+              by "short circuiting" the loading loop.  This  will  in  general
+              speed  up  loading, but may cause some loaders to fail. (Enabled
+              by default, but you can  use  `--no-accelerate-loader'  to  dis-
+              able). The same as the Media Options dialog's Accelerate loaders
+              option.
+
+       --aspect-hint
+              Specify whether the GTK+ and Xlib user interfaces should  `hint'
+              to  the  window manager about the preferred aspect ratio for the
+              graphics window, thus preventing resizing  to  non-square  sizes
+              which  lead  to  Fuse  not displaying correctly. This option has
+              been observed to cause problems with some window  managers  when
+              using  the  GTK+  UI  which  can  prevent  the window from being
+              resized or moved at all. (Enabled by default, but  you  can  use
+              `--no-aspect-hint'     to     disable).     See     also     the
+              `--strict-aspect-hint' option.
+
+       --autosave-settings
+              Specify whether Fuse's current settings should be  automatically
+              saved  on  exit.  The same as the General Options dialog's Auto-
+              save settings option.
+
+       --auto-load
+              Specify whether tape and  disk  files  should  be  automatically
+              loaded  when  they  are  opened  using  the  File, Open...  menu
+              option. In the case of TRD/SCL disk images, inserts also a  boot
+              loader file when none is available. (Enabled by default, but you
+              can use `--no-auto-load' to disable). Same as the Media  Options
+              dialog's Auto-load media option.
+
+       --beta128
+              Emulate  a  Beta 128  interface.  Same  as  the Disk Peripherals
+              Options dialog's Beta 128 interface option.
+
+       --beta128-48boot
+              When a Beta 128 interface is used in 48K or TC2048 emulation the
+              option  additionally controls whether the machine boots directly
+              into the TR-DOS system. Same as  the  Disk  Peripherals  Options
+              dialog's Beta 128 auto-boot in 48K machines option.
+
+       --betadisk file
+              Insert  the  specified  file  into the emulated Beta disk inter-
+              face's drive A: and select Pentagon mode on startup.
+
+       --bw-tv
+              Specify whether the display should simulate a  colour  or  black
+              and  white  television. This option is effective under the GTK+,
+              Win32, Xlib and SDL user interfaces: the others will always sim-
+              ulate  a  colour  TV.   The same as the General Options dialog's
+              Black and white TV option.
+
+       --cmos-z80
+              This option specifies that Fuse should emulate a  CMOS  Z80,  as
+              opposed to an NMOS Z80. Same as the General Options dialog's Z80
+              is CMOS option.
+
+       --competition-code code
+              Specify the code to be written to competition  mode  RZX  files.
+              The same as the RZX Options dialog's Competition code option.
+
+       --competition-mode
+              Specify  whether input recordings should be made in `competition
+              mode'.  The same as the RZX Options  dialog's  Competition  mode
+              option.
+
+       --compress-rzx
+              Specify  whether  RZX  files  should  be written out compressed.
+              (Enabled by default, but you can use `--no-compress-rzx' to dis-
+              able).  Same  as  the  RZX  Options  dialog's  Compress RZX data
+              option.
+
+       --confirm-actions
+              Specify whether `dangerous' actions  (those  which  could  cause
+              data loss, for example resetting the Spectrum) require confirma-
+              tion before occurring. (Enabled by  default,  but  you  can  use
+              `--no-confirm-actions'  to  disable). This option is the same as
+              the General Options dialog's Confirm actions option.
+
+       --covox
+              Emulate a Covox sound interface for Pentagon/Scorpion.  Same  as
+              the General Peripherals Options dialog's Covox option.
+
+       --debugger-command string
+              Specify  a  debugger  command to be run before emulator startup.
+              This can be used to set breakpoints or the like. Currently, this
+              is  the  only method to input multi-line debugger commands. (See
+              the MONITOR/DEBUGGER section for more information).
+
+       --detect-loader
+              Specify whether Fuse should attempt to detect when the  tape  is
+              being accessed and start and stop the virtual tape playing auto-
+              matically.   (Enabled   by   default,   but    you    can    use
+              `--no-detect-loader' to disable). Same as the Media Options dia-
+              log's Detect loaders option.
+
+       --disciple
+              Emulate a DISCiPLE  interface.  Same  as  the  Disk  Peripherals
+              Options dialog's DISCiPLE interface option.
+
+       --discipledisk file
+              Insert the specified file into the emulated DISCiPLE's drive 1.
+
+       --didaktik80
+              Emulate  a  Didaktik 80 (or Didaktik 40) disk interface. Same as
+              the Disk Peripherals  Options  dialog's  Didaktik  80  interface
+              option.
+
+       --didaktik80disk file
+              Insert  the  specified  file  into  the emulated Didaktik 80 (or
+              Didaktik 40)'s drive A.
+
+       --disk-ask-merge
+              Prompt the user to confirm whether Fuse should try to merge  the
+              `B' side of a disk image from a separate file when opening a new
+              single-sided disk image.
+
+       --disk-try-merge mode
+              Select whether Fuse should try to merge a separate file for  the
+              `B'  side  of a disk image separate file when opening a new disk
+              image. Most double sided disk images are dumped  as  two  single
+              sided  disk  images  e.g.  `Golden Axe - Side A.dsk' and `Golden
+              Axe - Side B.dsk'. So, if we want to play Golden Axe,  first  we
+              have  to  insert  the first disk image and when the game asks to
+              insert side B, we have to find and open the second  disk  image,
+              instead  of  just  `flip'-ing  the  disk  inside  the  drive. If
+              enabled, Fuse will try to open the second image too and create a
+              double  sided disk image (merging the two one sided disk images)
+              and insert this merged virtual disk into  the  disk  drive.  The
+              function  detects whether the file is one side of a double-sided
+              image  if  the  filename  matches  a   pattern   like   [Ss]ide[
+              _][abAB12][ _.] in the file name of a disk that is being opened.
+              If found, Fuse will try to open the other side of the  disk  too
+              substituting  the  appropriate  characters  in the filename e.g.
+              1->2, a->b, A->B. If successful  then  it  will  merge  the  two
+              images  and now we have a double sided disk in drive. This means
+              that if we open `Golden Axe - Side A.dsk', then Fuse will try to
+              open  `Golden Axe - Side B.dsk' too. Now, we can just `flip' the
+              disk if Golden Axe asks for `Side B'.  The available options are
+              Never, With single-sided drives and Always.
+
+       --divide
+              Emulate  the  DivIDE interface. The same as the Disk Peripherals
+              Options dialog's DivIDE interface option.
+
+       --divide-masterfile file
+       --divide-slavefile file
+              Specify an IDE image to be loaded  into  the  DivIDE's  emulated
+              master and slave drives respectively.
+
+       --divide-write-protect
+              Specify  that  the emulated DivIDE's write protect jumper should
+              be considered set. The same as the Disk Peripherals Options dia-
+              log's DivIDE write protect option.
+
+       --divmmc
+              Emulate  the  DivMMC interface. The same as the Disk Peripherals
+              Options dialog's DivMMC interface option.
+
+       --divmmc-file file
+              Specify an HDF image to be loaded  into  the  DivMMC's  emulated
+              memory card.
+
+       --divmmc-write-protect
+              Specify  that  the  emulated  DivMMC's write protect jumper that
+              protects EEPROM should be considered set. The same as  the  Disk
+              Peripherals Options dialog's DivMMC write protect option.
+
+       --dock file
+              Insert  the  specified file into the emulated Timex 2068 variant
+              dock; also select the TC2068 on startup if available.
+
+       -D mode
+       --doublescan-mode mode
+              Specify whether to use doublescan modes in the FB UI.  Available
+              values  for mode are 0, 1 and 2. 0 means `never doublescan' (use
+              640x480 at either 72 Hz or 60 Hz), whereas 1  and  2  both  mean
+              `try to use doublescan' and will fall back on the 640x480 modes.
+              1 selects 72 Hz modes (the same size and shape as  your  typical
+              640x480), and 2 selects 60 Hz modes (overscan).
+
+              If your monitor displays a blank screen when using 1 or 2, press
+              F10 then try a different option or say `--fbmode 640'.
+
+       --drive-plus3a-type type
+       --drive-plus3b-type type
+       --drive-beta128a-type type
+       --drive-beta128b-type type
+       --drive-beta128c-type type
+       --drive-beta128d-type type
+       --drive-plusd1-type type
+       --drive-plusd2-type type
+       --drive-didaktik80a-type type
+       --drive-didaktik80b-type type
+       --drive-disciple1-type type
+       --drive-disciple2-type type
+       --drive-opus1-type type
+       --drive-opus2-type type
+              Specify a disk drive type to emulate with the associated  inter-
+              face.   The  available  options  are  Disabled,  Single-sided 40
+              track, Double-sided 40 track, Single-sided  80  track  and  Dou-
+              ble-sided 80 track.  See the Disk Options dialog for more infor-
+              mation.  The Disabled option is not supported  for  Drive  1  or
+              Drive A of any interface.
+
+       --drive-40-max-track count
+       --drive-80-max-track count
+              Specify  the maximum number of tracks for 40 and 80 track physi-
+              cal drives respectively.
+
+       --embed-snapshot
+              Specify whether a snapshot should be embedded  in  an  RZX  file
+              when recording is started from an existing snapshot. (Enabled by
+              default, but you can use `--no-embed-snapshot' to disable). Same
+              as the RZX Options dialog's Always embed snapshot option.
+
+       --fastload
+              Specify  whether  Fuse  should run at the fastest possible speed
+              when the virtual tape is playing. (Enabled by default,  but  you
+              can  use  `--no-fastload'  to  disable).  The  same as the Media
+              Options dialog's Fastloading option.
+
+       -v mode
+       --fbmode mode
+              Specify which mode to use for the FB UI.  Available  values  for
+              mode  are  `320'  (which corresponds to a 320x240x256 mode), the
+              default and `640' (a 640x480x256 mode).
+
+       --fuller
+              Emulate a Fuller Box interface. Same as the General  Peripherals
+              Options dialog's Fuller Box option.
+
+       --full-screen
+              Specify  whether  Fuse  should  run  in  full screen mode.  This
+              option is effective only under the SDL UI.
+
+       -g filter
+       --graphics-filter mode
+              Specify which graphics filter to use if available.  The  default
+              is  normal,  which  uses no filtering. The available options are
+              2x, 2xsai, 3x, 4x, advmame2x, advmame3x, dotmatrix, half,  half-
+              skip,   hq2x,   hq3x,   hq4x,  normal,  super2xsai,  supereagle,
+              timex15x, timex2x, timextv, tv2x, tv3x,  tv4x,  paltv,  paltv2x,
+              and paltv3x.  See the GRAPHICS FILTERS section for more details.
+
+       --graphicsfile file
+              Set  the  filename  used  for graphical output from the emulated
+              ZX Printer. See the PRINTER EMULATION section for more details.
+
+       -h
+       --help
+              Give brief usage help, listing available options.
+
+       --if2cart file
+              Insert the specified file into the emulated Interface 2.
+
+       --interface1
+              Emulate a Sinclair Interface 1. Same as the General  Peripherals
+              Options dialog's Interface 1 option.
+
+       --interface2
+              Emulate a Sinclair Interface 2. (Enabled by default, but you can
+              use `--no-interface2' to disable). Same as the General Peripher-
+              als Options dialog's Interface 2 option.
+
+       --issue2
+              Emulate  an  issue 2  keyboard. Same as the General Options dia-
+              log's Issue 2 keyboard option.
+
+       -j device
+       --joystick-1 device
+              Read from device to emulate the first joystick.  Fuse  will  use
+              either `/dev/input/js0' or `/dev/js0' by default.
+
+       --joystick-2 device
+              As  for  --joystick-1  but  for the second joystick; the default
+              here is either `/dev/input/js1' or `/dev/js1'.
+
+       --joystick-1-output type
+       --joystick-2-output type
+       --joystick-keyboard-output type
+              Select which joystick interface to attach for the first two real
+              joysticks  and the keyboard joystick. The default is 0, which is
+              no output. The available options are 1 (cursor), 2 (kempston), 3
+              (Sinclair 1),  4  (Sinclair 2),  5 (Timex 1), 6 (Timex 2), and 7
+              (Fuller). Same as the Joysticks Options dialog's  Joystick  type
+              option.
+
+       --joystick-1-fire-1 code
+       --joystick-1-fire-2 code
+       --joystick-1-fire-3 code
+       --joystick-1-fire-4 code
+       --joystick-1-fire-5 code
+       --joystick-1-fire-6 code
+       --joystick-1-fire-7 code
+       --joystick-1-fire-8 code
+       --joystick-1-fire-9 code
+       --joystick-1-fire-10 code
+       --joystick-1-fire-11 code
+       --joystick-1-fire-12 code
+       --joystick-1-fire-13 code
+       --joystick-1-fire-14 code
+       --joystick-1-fire-15 code
+       --joystick-2-fire-1 code
+       --joystick-2-fire-2 code
+       --joystick-2-fire-3 code
+       --joystick-2-fire-4 code
+       --joystick-2-fire-5 code
+       --joystick-2-fire-6 code
+       --joystick-2-fire-7 code
+       --joystick-2-fire-8 code
+       --joystick-2-fire-9 code
+       --joystick-2-fire-10 code
+       --joystick-2-fire-11 code
+       --joystick-2-fire-12 code
+       --joystick-2-fire-13 code
+       --joystick-2-fire-14 code
+       --joystick-2-fire-15 code
+              Select which Fuse key code should be triggered by the applicable
+              real joystick button press. The  codes  are  the  Fuse  keyboard
+              codes corresponding to the keys. The default value is 4096 which
+              corresponds to the virtual joystick fire  button.  Same  as  the
+              Joysticks Options dialog's Joystick fire options.
+
+       --joystick-keyboard-up code
+       --joystick-keyboard-down code
+       --joystick-keyboard-left code
+       --joystick-keyboard-right code
+       --joystick-keyboard-fire code
+              Select which Fuse key code should correspond with each direction
+              and fire for the keyboard virtual joystick. The same as the Key-
+              board Joysticks Options dialog's Button for UP, Button for DOWN,
+              Button for LEFT, Button for RIGHT and Button  for  FIRE  options
+              respectively.
+
+       --joystick-prompt
+              If  this  option  is  specified, then Fuse will prompt you which
+              form of joystick emulation you wish to use when loading a  snap-
+              shot. No prompt will be issued if the configuration in the snap-
+              shot matches what you are currently using. The same as the  Gen-
+              eral Options dialog's Snap joystick prompt option.
+
+       --kempston
+              Emulate  a  Kempston  joystick.  Same as the General Peripherals
+              Options dialog's Kempston joystick option.
+
+       --kempston-mouse
+              Emulate a  Kempston  mouse.  Same  as  the  General  Peripherals
+              Options dialog's Kempston mouse option.
+
+       --keyboard-arrows-shifted
+              Treat  the  keyboard arrow keys as shifted like the ZX Spectrum+
+              keyboard's arrow keys or as unshifted  like  a  cursor  joystick
+              that  maps  to  the 5, 6, 7 and 8 keys. (Enabled by default, but
+              you can use `--no-keyboard-arrows-shifted' to disable). Same  as
+              the  General  Peripherals  Options dialog's Use shift with arrow
+              keys option.
+
+       --late-timings
+              It has been observed that some real Spectrums run such that  the
+              screen is rendered one tstate later than on other real hardware.
+              This option specifies that Fuse should emulate such  a  machine.
+              Same as the General Options dialog's Late timings option.
+
+       --loading-sound
+              Specify whether the sound made while tapes are loading should be
+              emulated. (Enabled by  default,  but  you  can  use  `--no-load-
+              ing-sound' to disable). Same as the Sound Options dialog's Load-
+              ing sound option.
+
+       -m type
+       --machine type
+              Specify machine type to emulate initially. The default is 48,  a
+              48K Spectrum.  The  available  options are 16, 48, 48_ntsc, 128,
+              plus2, plus2a, plus3, 2048, 2068, ts2068, pentagon, pentagon512,
+              pentagon1024, scorpion and se.
+
+       --melodik
+              Emulate a Melodik AY interface for 16/48k Spectrums. Same as the
+              General Peripherals Options dialog's Melodik option.
+
+       --mdr-len length
+              This option controls the number of blocks in  a  new  Microdrive
+              cartridge.  Same as the Media Options dialog's MDR cartridge len
+              option.
+
+       --mdr-random-len
+              If this option is set, Fuse will use a  random  Microdrive  car-
+              tridge  length. Same as the Media Options dialog's Random length
+              MDR cartridge option.
+
+       --microdrive-file file
+       --microdrive-2-file file
+       --microdrive-3-file file
+       --microdrive-4-file file
+       --microdrive-5-file file
+       --microdrive-6-file file
+       --microdrive-7-file file
+       --microdrive-8-file file
+              Specify Interface 1 Microdrive cartridge files to open.
+
+       --mouse-swap-buttons
+              Swap the left and right mouse buttons when emulating  the  Kemp-
+              ston  mouse.  The  same as the General Peripherals dialog's Swap
+              mouse buttons option.
+
+       --movie-compr level
+              This option  sets  the  compression  level  used  when  creating
+              movies.  Same  as  the  Movie Options dialog's Movie compression
+              option. The available  options  are  None,  Lossless,  and  High
+              (lossy).  The  default  option  is Lossless.  See also the MOVIE
+              RECORDING section.
+
+       --movie-start file
+              With this command line option, Fuse will start  movie  recording
+              as soon as the emulator is started. See also the MOVIE RECORDING
+              section.
+
+       --movie-stop-after-rzx
+              With this command line option, Fuse will  stop  movie  recording
+              when  RZX  playback  or  RZX  recording  ends. Same as the Movie
+              Options dialog's Stop recording after RZX ends option.  (Enabled
+              by  default, but you can use `--no-movie-stop-after-rzx' to dis-
+              able).  See also the MOVIE RECORDING section.
+
+       --multiface1
+              Emulate a Romantic Robot Multiface One interface.  Same  as  the
+              General Peripherals Options dialog's Multiface One option.
+
+       --multiface128
+              Emulate  a  Romantic  Robot Multiface 128 interface. Same as the
+              General Peripherals Options dialog's Multiface 128 option.
+
+       --multiface3
+              Emulate a Romantic Robot Multiface 3 interface. Same as the Gen-
+              eral Peripherals Options dialog's Multiface 3 option.
+
+       --multiface1-stealth
+              Set  Multiface  One  stealth/invisible mode. Same as the General
+              Peripherals Options dialog's Stealth Multiface One option.
+
+       --opus
+              Emulate an Opus Discovery interface. Same as the Disk  Peripher-
+              als Options dialog's Opus Discovery interface option.
+
+       --opusdisk file
+              Insert  the  specified  file  into the emulated Opus Discovery's
+              drive 1.
+
+       --pal-tv2x
+              Specify whether the PAL TV 2x and PAL TV 3x scalers should  also
+              produce  scanlines  along  the  lines  of the TV 2x and Timex TV
+              scalers.  The same as the General Options  dialog's  PAL-TV  use
+              TV2x effect option.
+
+       --phantom-typist-mode mode
+              Specify  the keystroke sequence that the "phantom typist" should
+              use when starting a program loading. The available  options  are
+              Auto, Keyword, Keystroke, Menu, Plus 2A and Plus 3.  The same as
+              the Media Options dialog's Phantom typist mode option.
+
+       -p file
+       --playback file
+              Specify an RZX file to begin playback from.
+
+       --plus3disk file
+              Insert the specified file into the emulated +3's A: drive;  also
+              select the +3 on startup if available.
+
+       --plus3-detect-speedlock
+              Specify  whether the +3 drives try to detect Speedlock protected
+              disks, and emulate `weak' sectors.  If the disk image file (EDSK
+              or  UDI)  contains weak sector data, than Speedlock detection is
+              automatically omitted.  See also the  WEAK  DISK  DATA  section.
+              Same as the Disk Options dialog's +3 Detect Speedlock option.
+
+       --plusd
+              Emulate  a  +D  interface.  Same as the Disk Peripherals Options
+              dialog's +D interface option.
+
+       --plusddisk file
+              Insert the specified file into the emulated +D's drive 1.
+
+       --printer
+              Specify whether the emulation should include a printer. Same  as
+              the   General  Peripherals  Options  dialog's  Emulate  printers
+              option.
+
+       --rate frame
+              Specify the frame rate, the ratio of spectrum frame  updates  to
+              real  frame  updates. Same as the General Options dialog's Frame
+              rate option.
+
+       -r file
+       --record file
+              Specify an RZX file to begin recording to.
+
+       --recreated-spectrum
+              Enable the use of a Recreated ZX Spectrum in  `Layer  A'  (game)
+              mode.  This  is  a  Bluetooth keyboard that can be paired to the
+              device where Fuse is running. The same as  the  General  Options
+              dialog's Recreated ZX Spectrum option.
+
+       --rom-16 file
+       --rom-48 file
+       --rom-128-0 file
+       --rom-128-1 file
+       --rom-plus2-0 file
+       --rom-plus2-1 file
+       --rom-plus2a-0 file
+       --rom-plus2a-1 file
+       --rom-plus2a-2 file
+       --rom-plus2a-3 file
+       --rom-plus3-0 file
+       --rom-plus3-1 file
+       --rom-plus3-2 file
+       --rom-plus3-3 file
+       --rom-plus3e-0 file
+       --rom-plus3e-1 file
+       --rom-plus3e-2 file
+       --rom-plus3e-3 file
+       --rom-tc2048 file
+       --rom-tc2068-0 file
+       --rom-tc2068-1 file
+       --rom-ts2068-0 file
+       --rom-ts2068-1 file
+       --rom-pentagon-0 file
+       --rom-pentagon-1 file
+       --rom-pentagon-2 file
+       --rom-pentagon512-0 file
+       --rom-pentagon512-1 file
+       --rom-pentagon512-2 file
+       --rom-pentagon512-3 file
+       --rom-pentagon1024-0 file
+       --rom-pentagon1024-1 file
+       --rom-pentagon1024-2 file
+       --rom-pentagon1024-3 file
+       --rom-scorpion-0 file
+       --rom-scorpion-1 file
+       --rom-scorpion-2 file
+       --rom-scorpion-3 file
+       --rom-spec-se-0 file
+       --rom-spec-se-1 file
+              Specify  the  file  to be used for ROM(s) used for each machine.
+              The options respectively refer  to  the  16K Spectrum  (48.rom),
+              48K Spectrum  (48.rom),  the  two  ROMs  for  the  128K Spectrum
+              (128-0.rom and 128-1.rom), the two ROMs for the +2  (plus2-0.rom
+              and  plus2-1.rom),  the  four  ROMs  for  the  +2A (plus3-0.rom,
+              plus3-1.rom, plus3-2.rom and plus3-3.rom), the four ROMs for the
+              +3  (plus3-0.rom, plus3-1.rom, plus3-2.rom and plus3-3.rom), the
+              four enhanced ROMs  for  the  +3e  (plus3e-0.rom,  plus3e-1.rom,
+              plus3e-2.rom and plus3e-3.rom), the TC2048 ROM (tc2048.rom), the
+              two ROMs for the TC2068 (tc2068-0.rom and tc2068-1.rom), the two
+              ROMs  for  the  TS2068  (tc2068-0.rom and tc2068-1.rom), the two
+              main ROMs and the TR-DOS ROM for the Pentagon 128K  (128p-0.rom,
+              128p-1.rom and trdos.rom), the two main ROMs, the TR-DOS ROM and
+              a reset service ROM for the Pentagon 512K and 1024K (128p-0.rom,
+              128p-1.rom,  trdos.rom  and  gluck.rom),  the  four ROMs for the
+              Scorpion   256   (256s-0.rom,   256s-1.rom,    256s-2.rom    and
+              256s-3.rom),  and the two ROMs for the Spectrum SE (se-0.rom and
+              se-1.rom).
+
+              The names in brackets denote the defaults.  Note  that  not  all
+              these  ROMs  are  supplied with Fuse -- you must supply your own
+              copies of those which are not.
+
+       --rom-interface-1 file
+       --rom-beta128 file
+       --rom-plusd file
+       --rom-didaktik80 file
+       --rom-disciple file
+       --rom-multiface1 file
+       --rom-multiface128 file
+       --rom-multiface3 file
+       --rom-opus file
+       --rom-speccyboot file
+       --rom-usource file
+              Specify the file to be used for ROM(s) used for each peripheral.
+              The   options   respectively   refer   to  the  Interface 1  ROM
+              (if1-2.rom), the TR-DOS ROM for Beta 128 emulation with the 48K,
+              TC2048,  128K  or  +2  (trdos.rom),  the +D ROM (plusd.rom), the
+              Didaktik 80  ROM  (didaktik80.rom),  the  DISCiPLE  ROM  (disci-
+              ple.rom), the Multiface One ROM (mf1.rom), the Multiface 128 ROM
+              (mf128.rom), the Multiface 3 ROM (mf3.rom), the  Opus  Discovery
+              ROM (opus.rom), the SpeccyBoot ROM (speccyboot-1.4.rom), and the
+              Source ROM (usource.rom).
+
+              The names in brackets denote the defaults.  Note  that  not  all
+              these  ROMs  are  supplied with Fuse -- you must supply your own
+              copies of those which are not.
+
+       --no-rs232-handshake
+              This option makes Fuse's Interface 1 emulation assume  that  the
+              RS-232 line other end is live when you connect the communication
+              channels.  See also the `--rs232-rx' and `--rs232-tx' options.
+
+       --rs232-rx
+       --rs232-tx
+              Specify the communication channels (FIFO or file) to be used for
+              Interface 1  RS-232  emulation as RxD and TxD wire. See also the
+              `--rs232-handshake' options.
+
+       --rzx-autosaves
+              Specify that, while recording an RZX file, Fuse should automati-
+              cally  add  a  snapshot to the recording stream every 5 seconds.
+              (Default to on, but you can  use  `--no-rzx-autosaves'  to  dis-
+              able). Same as the RZX Options dialog's Create autosaves option;
+              see there for more details.
+
+       --sdl-fullscreen-mode mode
+              Select a screen resolution for full screen mode. Available  val-
+              ues  for  mode  are  listed in a table, when Fuse is called with
+              --sdl-fullscreen-mode list command line option.  This option  is
+              effective only under the SDL UI.
+
+       --separation type
+              Give  stereo  separation of the 128's AY sound channels. Same as
+              the General Options dialog's AY stereo  separation  option.  The
+              available options are None, ACB, and ABC.  The default option is
+              None.
+
+       --simpleide
+              Specify whether Fuse will emulate the simple 8-bit IDE interface
+              as  used  by  the  Spectrum +3e.  Same  as  the Disk Peripherals
+              Options dialog's Simple 8-bit IDE option.
+
+       --simpleide-masterfile file
+              Specify a HDF file to connect to the emulated Simple  8-bit  IDE
+              interface's master channel.
+
+       --simpleide-slavefile file
+              Specify  a  HDF file to connect to the emulated Simple 8-bit IDE
+              interface's slave channel.
+
+       --slt
+              Support the SLT trap instruction. (Enabled by default,  but  you
+              can  use  `--no-slt' to disable). Same as the Media Options dia-
+              log's Use .slt traps option.
+
+       -s file
+       --snapshot file
+              Specify a snapshot file to load. The file can be in any snapshot
+              format supported by libspectrum(3).
+
+       --sound
+              Specify  whether Fuse should produce sound. (Enabled by default,
+              but you can use `--no-sound' to  disable).  Same  as  the  Sound
+              Options dialog's Sound enabled option.
+
+       -d device
+       --sound-device device
+              Specify  the  sound output device to use and any options to give
+              that device. If you are not using the SDL UI or using  libao  or
+              libasound  (ALSA)  for  sound  output, then the device parameter
+              just specifies the device to be used for sound output.
+
+              If you are using the SDL UI, the device parameter allows you  to
+              specify  the  audio  driver to be used (e.g. dsp, alsa, dma, esd
+              and arts).
+
+              If you are using libao for sound output,  the  device  parameter
+              allows  you  to specify the device used for sound output (either
+              `live' to a speaker or to a file) and the parameters to be  used
+              for  that  device. In general, the device parameter has the form
+              driver[:param[=value][,param[=value][,...]].  driver selects the
+              libao driver to be used, either one of the `live' drivers (aixs,
+              alsa, alsa09, arts, esd, irix, macosx, nas, oss  or  sun)  or  a
+              file driver (au, raw, wav or null).  The available parameter and
+              value pairs for each device are:
+
+              o      aixs: AIX audio system
+
+                     o      dev=device
+                            `device' gives the AIX sound device.
+
+              o      alsa: Advanced Linux Sound Architecture version 0.5.x
+
+                     o      card=num
+                            `num' gives the ALSA card number.
+
+                     o      dev=num
+                            `num' gives the ALSA device number.
+
+                     o      buf_size=num
+                            `num' gives the ALSA buffer size in bytes.
+
+              o      alsa09: Advanced Linux Sound Architecture version 0.9+
+
+                     o      dev=string
+                            `string' specifies the ALSA device e.g. hw:1.2
+
+                     o      buffer_time=num
+                            `num' gives the ALSA buffer time in microseconds.
+
+                     o      period_time=num
+                            `num' gives the ALSA period time in microseconds.
+
+                     o      use_mmap=yes|y|true|t|1
+                            specifies that libao use memory mapped transfer.
+
+              o      arts: aRts soundserver: no parameters.
+
+              o      esd: Enlightened Sound Daemon.
+
+                     o      host=string
+                            `string' gives the ESD host specification.
+
+              o      irix: IRIX Audio Library: no parameters.
+
+              o      macosx: MacOS X CoreAudio: no parameters.
+
+              o      nas: Network Audio System.
+
+                     o      host=string
+                            `string' gives the NAS host specification.
+
+                     o      buf_size=num
+                            `num' gives the buffer size on the server.
+
+              o      oss: Open Sound System.
+
+                     o      dsp=string
+                            `string' gives the OSS  device  to  be  used  e.g.
+                            /dev/sound/dsp1
+
+              o      sun: SUN audio system.
+
+                     o      dev=string
+                            `string' gives the audio device to be used.
+
+              o      au: SUN Sparc audio file: no parameters.
+
+              o      raw: raw file.
+
+                     o      byteorder=string
+                            `string'  can  be any of native (host native byte-
+                            order),  big  (big  endian)  or   little   (little
+                            endian).
+
+              o      wav: Microsoft audio file: no parameters.
+
+              o      null: null output: no parameters.
+
+              o      debug: for debugging libao.
+
+              Finally, each of the file output types (au, raw and wav) have an
+              extra option `file=filename' where  `filename'  gives  the  file
+              output  will be directed to. This defaults to `fuse-sound.ao' if
+              it is not specified.
+
+              Some examples of use:
+
+              fuse -d alsa09:dev=hw:1
+
+              causes Fuse to use ALSA 0.9+ output with the second  (#1)  sound
+              card.
+
+              fuse -d raw:byteorder=little,file=enigma.raw
+
+              causes Fuse to save little endian words to `enigma.raw'.
+
+              See the `DEVICE' section of ogg123(1) for up to date information
+              of devices and options (except for the `file'  option  which  is
+              provided by Fuse itself).
+
+              If  you are using libasound or ALSA for sound output, the device
+              parameter allows you to specify the device used for sound output
+              and  some parameters to be used for that device. In general, the
+              device parameter has the form
+              devstr or
+              param[=value][,param[=value][,...][,devstr].
+
+              o      devstr: selects the ALSA device used, it can be any  com-
+                     plex or simple ALSA device name. e.g.: default or hw:0 or
+                     tee:plughw:0,'/tmp/out.raw',raw.  See  the  alsa-lib  pcm
+                     api                      reference                     at
+                     http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html
+                     for further explanation.
+
+              o      param and values:
+
+                     o      buffer=nnnn:   set  the  ALSA  buffer  in  frames,
+                            smaller value cause smaller sound  delay  but  may
+                            more  buffer  underrun  (pops  and clicks), larger
+                            value cause longer delay but  fewer  underrun.  By
+                            default  Fuse  determine  the buffer size based on
+                            the actual sound frequency.
+
+                            If you use some special plugin for your pcm device
+                            (e.g.:  dmix) or your card not support some needed
+                            parameter (e.g.  cannot  play  other  only  48 kHz
+                            stereo  sound like some AC97 sound card) may cause
+                            Fuse unable to set the needed buffer size,  appro-
+                            priate sound frequency, channels and so on, there-
+                            fore you cannot get optimal result or not hear the
+                            sound  at  all.  In  this  case  try the plughw:#,
+                            (where # mean your card number counted from 0) for
+                            ALSA device.
+
+                     o      verbose : if given, fuse report ALSA buffer under-
+                            runs to stderr.
+
+              Some examples of use:
+
+              fuse -d verbose,buffer=2000
+
+              causes Fuse to use the  default  ALSA  device  with  2000  frame
+              length buffer and report ALSA buffer underruns on stderr.
+
+              fuse -d tee:plughw:0,'/tmp/aufwm.raw',raw
+
+              causes  Fuse  to  use  the  first card and parallel save the raw
+              audio samples into /tmp/aufwm.raw file.
+
+       --sound-force-8bit
+              Force the use of 8-bit sound, even if 16-bit is  possible.  Same
+              as the Sound Options dialog's Force 8-bit option.
+
+       -f frequency
+       --sound-freq frequency
+              Specify what frequency Fuse should use for the sound device, the
+              default is 44.1 kHz, but some devices only support a single fre-
+              quency or a limited range (e.g.  48 kHz or up to 22 kHz).
+
+       --speaker-type type
+              Select  the  output  speaker  emulation, type can be TV speaker,
+              Beeper or Unfiltered. Same as the Sound Options dialog's Speaker
+              type option.
+
+       --speccyboot
+              Emulate  a  SpeccyBoot  Ethernet  interface. Same as the General
+              Peripherals Options dialog's SpeccyBoot option. See the  Speccy-
+              Boot  web page at http://patrikpersson.github.io/speccyboot/ for
+              full details on the SpeccyBoot.
+
+       --speccyboot-tap device
+              Specify the TAP device to use for SpeccyBoot emulation.
+
+       --specdrum
+              Emulate a SpecDrum interface. Same as  the  General  Peripherals
+              Options  dialog's  SpecDrum  option.  See  the World of Spectrum
+              Infoseek  web  page   at   http://www.worldofspectrum.org/infos-
+              eekid.cgi?id=1000062 for manuals, software and more.
+
+       --spectranet
+              Specify whether Fuse will emulate the Spectranet Ethernet inter-
+              face.  Same as the General Peripherals  Options  dialog's  Spec-
+              tranet  option.  See  the  SPECTRANET EMULATION section for more
+              details.
+
+       --spectranet-disable
+              This option controls the state of the Spectranet automatic page-
+              in jumper (J2). Same as the General Peripherals Options dialog's
+              Spectranet disable option. See the SPECTRANET EMULATION  section
+              for more details.
+
+       --speed percentage
+              Specify  the  speed  (as a percentage of real Spectrum speed) at
+              which emulation should attempt to proceed. Same as  the  General
+              Options dialog's Emulation speed option.
+
+       --statusbar
+              For  the  GTK+  and  Win32 UI, enables the statusbar beneath the
+              display. For the Xlib and SDL UI, enables the status icons show-
+              ing  whether  the  disk and tape are being accessed. Same as the
+              General Options dialog's Show statusbar option.
+
+       --strict-aspect-hint
+              For the GTK+ UI, use stricter limits for the aspect ratio limits
+              set  by  the  `--aspect-hint' option. This can cause some window
+              managers (for example, metacity(1)) to not allow the  window  to
+              be  resized  and  moved, but is necessary to prevent others (for
+              example, fvwm(1)) from being able resize the  window  away  from
+              square.
+
+       --svga-modes mode1,mode2,mode3
+              Specify  which  SVGA mode to use for the SVGAlib UI at different
+              screen sizes. Available values for mode1, mode2  and  mode3  are
+              listed  in a table, when Fuse called with --svga-modes list com-
+              mand line option.  When user select a not available mode  for  a
+              size,  Fuse  just  ignore  and try to find the best mode for it.
+              e.g.  with  --svga-modes   0,0,12   Fuse   use   the   specified
+              1024x768x256  SVGA mode for triple size filters, but select SVGA
+              modes automatically for normal  or  double  size  filters.   The
+              above mode number is just an example, and mode numbers and their
+              meanings may vary graphics card by graphics card.
+
+       -t file
+       --tape file
+              Specify a virtual tape file to use. It must be in  PZX,  TAP  or
+              TZX format.
+
+       --textfile file
+              Set  the  filename used for text output from the emulated print-
+              ers. See the PRINTER EMULATION section below for more details.
+
+       --traps
+              Support traps for ROM tape loading/saving. (Enabled by  default,
+              but  you  can  use  `--no-traps'  to disable). Same as the Media
+              Options dialog's Use tape traps option.
+
+       --unittests
+              This option runs a testing framework that  automatically  checks
+              portions  of  code, comparing actual results with expected ones.
+              It is meant to detect broken code before a release. There is not
+              graphical  mode,  the  program just ends with exit code 0 if all
+              tests are good or prints error messages to stdout and ends  with
+              exit code greater than 0 if there are failed tests.
+
+       --usource
+              Emulate  a  Source  interface.  Same  as the General Peripherals
+              Options dialog's Source option.
+
+       -V
+       --version
+              Show which version of Fuse is being used.
+
+       --volume-ay volume
+              Sets the relative volume of the AY-3-8912 chip from a  range  of
+              0-100%. Same as the Sound Options dialog's AY volume option.
+
+       --volume-beeper volume
+              Sets  the  relative volume of the beeper from a range of 0-100%.
+              Same as the Sound Options dialog's Beeper volume option.
+
+       --volume-covox volume
+              Sets the relative volume of the Covox from a  range  of  0-100%.
+              Same as the Sound Options dialog's Covox volume option.
+
+       --volume-specdrum volume
+              Sets the relative volume of the SpecDrum from a range of 0-100%.
+              Same as the Sound Options dialog's SpecDrum volume option.
+
+       --writable-roms
+              Allow Spectrum programs to overwrite the ROM(s). The same as the
+              General Options dialog's Allow writes to ROM option.
+
+       --zxatasp
+              Specify  whether Fuse emulate the ZXATASP interface. Same as the
+              Disk Peripherals Options dialog's ZXATASP interface option.
+
+       --zxatasp-upload
+              Specify the state of the ZXATASP upload jumper. Same as the Disk
+              Peripherals Options dialog's ZXATASP upload option.
+
+       --zxatasp-write-protect
+              Specify  the  state of the ZXATASP write protect jumper. Same as
+              the Disk Peripherals  Options  dialog's  ZXATASP  write  protect
+              option.
+
+       --zxatasp-masterfile file
+              Specify  a  HDF  file  to connect to the emulated ZXATASP inter-
+              face's master channel.
+
+       --zxatasp-slavefile file
+              Specify a HDF file to connect to  the  emulated  ZXATASP  inter-
+              face's slave channel.
+
+       --zxcf
+              Specify  whether  Fuse  emulate  the ZXCF interface. Same as the
+              Disk Peripherals Options dialog's ZXCF interface option.
+
+       --zxcf-upload
+              Specify the state of the ZXCF upload jumper. Same  as  the  Disk
+              Peripherals Options dialog's ZXCF upload option.
+
+       --zxcf-cffile file
+              Specify a HDF file to connect to the emulated ZXCF interface.
+
+       --zxmmc
+              Emulate  the  ZXMMC  interface. The same as the Disk Peripherals
+              Options dialog's ZXMMC interface option.
+
+       --zxmmc-file file
+              Specify an HDF image to be loaded into the ZXMMC's emulated mem-
+              ory card.
+
+       --zxprinter
+              Emulate  the ZX Printer. Same as the General Peripherals Options
+              dialog's ZX Printer option.
+
+       All long options which control on/off settings can  be  disabled  using
+       `--no-foo'  (for  an  option  `--foo').   For  example, the opposite of
+       `--issue2' is `--no-issue2'.  These options can also be modified  while
+       the  emulator is running, using the options dialogs -- see the documen-
+       tation for the Options menu in the MENUS AND KEYS section for details.
+
+THE VARIOUS FRONT-ENDS
+       Fuse supports various front-ends, or UIs (user interfaces).  The  usual
+       one  is  GTK+-based,  but  there are also SDL, Win32, Xlib, SVGAlib and
+       framebuffer ones.
+
+       The important difference to note is that GTK+ and Win32  versions  uses
+       `native'  dialog  boxes  etc.  (behaving like a fairly normal GUI-based
+       program) while the others use  an  alternative,  Fuse-specific  `widget
+       UI'.  This  latter  front-end  is easily spotted by the way it uses the
+       main Fuse window/screen for menus and dialogs, and uses the  Spectrum's
+       own font.
+
+MENUS AND KEYS
+       Since  many of the keys available are devoted to emulation of the Spec-
+       trum's keyboard, the primary way of  controlling  Fuse  itself  (rather
+       than  the  emulated  machine) is via the menus. There are also function
+       key shortcuts for some menu options.
+
+       In the GTK+ and Win32 version, the menu bar is always  visible  at  the
+       top  of  the  Fuse  window.  You can click on a menu name to pop it up.
+       Alternatively, you can press F1 to display a pop-up version of the menu
+       bar, which you can then navigate with the cursor keys or mouse.
+
+       In  the widget UI pressing F1 is the only way to get the main menu; and
+       unlike the GTK+ version, the emulator pauses while the menus are  being
+       navigated.  The  menus  show which key to press for each menu option in
+       brackets. Pressing Esc exits a menu, and pressing Enter exits the  menu
+       system entirely (as well as `confirming' any current dialog).
+
+       Here's  what  the menu options do, along with the function key mappings
+       for those items which have them:
+
+       F3
+       File, Open...
+              Open a Spectrum file. Snapshots will be loaded into memory; tape
+              images  will be inserted into the emulated tape deck, and if the
+              Auto-load media option is set will being loading. Opening a disk
+              image  or  a Timex dock image will cause the appropriate machine
+              type (+3, Pentagon or TC2068) to  be  selected  with  the  image
+              inserted,  and  disks  will  automatically load if the Auto-load
+              media option is set. See the FILE SELECTION  section  below  for
+              details  on  how to choose the file. Note that this behaviour is
+              different from previous versions of Fuse, when this option would
+              open only snapshots.
+
+       F2
+       File, Save Snapshot...
+              Save  a snapshot (machine state, memory contents, etc.) to file.
+              You can select the filename to be saved to. If it  has  a  .szx,
+              .z80  or .sna extension, the snapshot will be saved in that for-
+              mat. Otherwise, it will be saved as a .szx file.
+
+       File, Recording, Record...
+              Start recording input to an RZX file, initialised from the  cur-
+              rent  emulation  state.  You  will be prompted for a filename to
+              use.
+
+       File, Recording, Record from snapshot...
+              Start recording input to an RZX file, initialised from  a  snap-
+              shot.  You  will first be asked for the snapshot to use and then
+              the file to save the recording to.
+
+       File, Recording, Continue recording...
+              Continue recording input into an existing RZX file from the last
+              recorded state. Finalised recordings cannot be resumed. You will
+              be prompted for the recording to continue.
+
+       Insert
+       File, Recording, Insert snapshot
+              Inserts a snapshot of the current state into the RZX file.  This
+              can  be used at a later point to roll back to the inserted state
+              by using one of the commands below.
+
+       Delete
+       File, Recording, Rollback
+              Rolls back the recording to the  point  at  which  the  previous
+              snapshot was inserted. Recording will continue from that point.
+
+       File, Recording, Rollback to...
+              Roll  back the recording to any snapshot which has been inserted
+              into the recording.
+
+       File, Recording, Play...
+              Playback recorded input from an RZX file. This lets  you  replay
+              keypresses  recorded  previously.  RZX files generally contain a
+              snapshot with the Spectrum's state at the start of  the  record-
+              ing;  if the selected RZX file doesn't, you'll be prompted for a
+              snapshot to load as well.
+
+       File, Recording, Stop
+              Stop any currently-recording/playing RZX file.
+
+       File, Recording, Finalise...
+              Compact an RZX file. Any interspersed snapshot will  be  removed
+              and  the  recording cannot be continued. All action replays sub-
+              mitted to the RZX Archive should be finalised.
+
+       File, AY Logging, Record...
+              Start recording the bytes output via the AY-3-8912 sound chip to
+              a  PSG  file.  You  will  be prompted for a filename to save the
+              recording to.
+
+       File, AY Logging, Stop
+              Stop any current AY logging.
+
+       File, Screenshot, Open SCR Screenshot...
+              Load an SCR screenshot (essentially just a binary  dump  of  the
+              Spectrum's  video memory) onto the current screen. Fuse supports
+              screenshots saved in the Timex hi-colour  and  hi-res  modes  as
+              well  as  `normal' Spectrum screens, and will make a simple con-
+              version if a hi-colour or hi-res screenshot  is  loaded  onto  a
+              non-Timex machine.
+
+       File, Screenshot, Save Screen as SCR...
+              Save  a copy of whatever's currently displayed on the Spectrum's
+              screen as an SCR file. You will be prompted for  a  filename  to
+              save the screenshot to.
+
+       File, Screenshot, Open MLT Screenshot...
+              Load  an  MLT screenshot onto the current screen. The MLT format
+              is similar to the SCR format but additionally supports capturing
+              images  that  use techniques to display more than two colours in
+              each Spectrum attribute square. Fuse will only load  the  bitmap
+              version  of  an image on a Sinclair machine but on a Timex clone
+              it can show the full colour detail  captured  in  the  image  by
+              using the hi-colour mode.
+
+       File, Screenshot, Save Screen as MLT...
+              Save  a copy of whatever's currently displayed on the Spectrum's
+              screen as an MLT file. You will be prompted for  a  filename  to
+              save the screenshot to.
+
+       File, Screenshot, Save Screen as PNG...
+              Save  the current screen as a PNG file. You will be prompted for
+              a filename to save the screenshot to.
+
+       File, Scalable Vector Graphics, Start capture in line mode...
+              Start trapping the video output functions present in ROM to copy
+              the picture to SVG files, thus creating vectorized scalable pic-
+              ture; it is expected to be fully operational in BASIC only,  but
+              few  machine  code  programs  could  work,  if  they use the ROM
+              addresses to output text or graphics. The initial  picture  size
+              is 256x176, but it is increased everytime a `scroll' happens. On
+              every CLS a  new  file  will  be  created,  with  an  increasing
+              sequence  number.  CIRCLEs  will  be  described as a sequence of
+              lines, so the original `imprecisions'  will  be  still  visible.
+              The  text  output  will  be fully understood and decoded: normal
+              ASCII characters will be converted into COURIER scalable  fonts,
+              UDG  graphics  into dot matrix areas, GRAPHICS blocky characters
+              into small squares.  A slightly transparent  output  permits  to
+              show  a  bit of the overlapped text and graphics elements. Lower
+              portion of the screen (normally bound to stream #0 and #1) won't
+              be captured.
+
+       File, Scalable Vector Graphics, Start capture in dot mode...
+              As  above, but line capture is disabled. A line will be rendered
+              as a sequence of dots.
+
+       File, Scalable Vector Graphics, Stop capture
+              Stop the SVG capture function.
+
+       File, Movie, Record...
+              Fuse can record movie (video and audio) into a file with special
+              format  which can be converted later to a common video file for-
+              mat with the fmfconv(1) utility.  You will  be  prompted  for  a
+              filename to save video. Please see MOVIE RECORDING section.
+
+       File, Movie, Record from RZX...
+              Start  movie  recording  and  RZX playback at the same time. You
+              will be prompted for a filename to play from and a  filename  to
+              save video.
+
+       File, Movie, Pause
+              Pause movie recording which is currently in progress.
+
+       File, Movie, Continue
+              Resume movie recording which has been previously paused.
+
+       File, Movie, Stop
+              Stop movie recording which is currently in progress.
+
+       File, Load Binary Data...
+              Load  binary  data from a file into the Spectrum's memory. After
+              selecting the file to load data from, you can  choose  where  to
+              load the data and how much data to load.
+
+       File, Save Binary Data...
+              Save  an  arbitrary  chunk  of  the Spectrum's memory to a file.
+              Select the file you wish to save to, followed  by  the  location
+              and length of data you wish to save.
+
+       F10
+       File, Exit
+              Exit  the  emulator.  A confirmation dialog will appear checking
+              you actually want to do this.
+
+       F4
+       Options, General...
+              Display the General Options dialog, letting you configure  Fuse.
+              (With  the  widget  UI,  the  keys  shown in brackets toggle the
+              options, Enter confirms any changes, and Esc aborts). Note  that
+              any changed settings only apply to the currently-running Fuse.
+
+              The options available are:
+
+              Emulation speed
+                     Set  how  fast Fuse will attempt to emulate the Spectrum,
+                     as a percentage of the speed at which  the  real  machine
+                     runs.  If  your machine isn't fast enough to keep up with
+                     the requested speed, Fuse will just run  as  fast  as  it
+                     can.  Note  that  if  the  emulation speed is faster than
+                     500%, no sound output will be produced.
+
+              Frame rate
+                     Specify the frame  rate,  the  ratio  of  spectrum  frame
+                     updates  to  real  frame  updates. This is useful if your
+                     machine is having trouble keeping up  with  the  spectrum
+                     screen updates.
+
+              Issue 2 keyboard
+                     Early versions of the Spectrum used a different value for
+                     unused bits on the keyboard input ports, and a few  games
+                     depended  on  the  old value of these bits. Enabling this
+                     option switches to the old value, to let you run them.
+
+              Recreated ZX Spectrum
+                     Enable the use of a Recreated ZX Spectrum  in  `Layer  A'
+                     (game)  mode.  This  is  a Bluetooth keyboard that can be
+                     paired to the device where Fuse is running.
+
+              Use shift with arrow keys
+                     Treat the keyboard arrow keys  as  shifted  like  the  ZX
+                     Spectrum+  keyboard's  arrow  keys or as unshifted like a
+                     cursor joystick that maps to the 5, 6, 7 and 8 keys.
+
+              Allow writes to ROM
+                     If this option is selected, Fuse will happily allow  pro-
+                     grams to overwrite what would normally be ROM. This prob-
+                     ably isn't very useful in most circumstances,  especially
+                     as the 48K ROM overwrites parts of itself.
+
+              Late timings
+                     If  selected,  Fuse will cause all screen-related timings
+                     (for example, when the screen is rendered and when memory
+                     contention  occurs) to be one tstate later than "normal",
+                     an effect which is present on some real hardware.
+
+              Z80 is CMOS
+                     If selected, Fuse will emulate a CMOS Z80, as opposed  to
+                     an  NMOS  Z80.   The undocumented `OUT (C),0' instruction
+                     will be replaced with `OUT (C),255' and  emulation  of  a
+                     minor  timing bug in the NMOS Z80's `LD A,I' and `LD A,R'
+                     instructions will be disabled.
+
+              RS-232 handshake
+                     If you turn this option off, Fuse assumes the RS-232 line
+                     other  end  is  live  when  you connect the communication
+                     channels.  See also  the  `--rs232-rx'  and  `--rs232-tx'
+                     options.
+
+              Black and white TV
+                     This  option  allows  you to choose whether to simulate a
+                     colour or black and white television. This  is  effective
+                     only under the GTK+, Win32, Xlib and SDL user interfaces:
+                     the others will always simulate a colour TV.
+
+              PAL-TV use TV2x effect
+                     This option allows you to choose  whether  the  PAL TV 2x
+                     and  higher  scalers also reproduce scanlines in the same
+                     way as the TV 2x, TV 3x and Timex TV scalers.
+
+              Show statusbar
+                     For the GTK+ and Win32 UI, enables the statusbar  beneath
+                     the  display.  For  the  SDL UI, enables the status icons
+                     showing whether the disk and  tape  are  being  accessed.
+                     This option has no effect for the other user interfaces.
+
+              Snap joystick prompt
+                     If  set,  Fuse will prompt you which physical joystick or
+                     keyboard you want to connect to  the  joystick  interface
+                     enabled  in  the  snapshot unless it already matches your
+                     current configuration.
+
+              Confirm actions
+                     Specify whether `dangerous' actions  (those  which  could
+                     cause  data  loss,  for  example  resetting the Spectrum)
+                     require confirmation before occurring.
+
+              Auto-save settings
+                     If this option is selected, Fuse will automatically write
+                     its  currently selected options to its configuration file
+                     on exit (either in xml format if  libxml2  was  available
+                     when  Fuse was compiled or plain text). If this option is
+                     off, you'll have to manually use Options, Save afterwards
+                     to  ensure  that this setting gets written to Fuse's con-
+                     figuration file. Note that if you turn  this  option  on,
+                     loading a snapshot could enable peripherals that would be
+                     written permanently to the configuration file.
+
+       Options, Media...
+              Display the Media Options dialog, letting you  configure  Fuse's
+              tape and Microdrive options. (With the widget UI, the keys shown
+              in brackets toggle the options, Enter confirms any changes,  and
+              Esc  aborts).  Note  that any changed settings only apply to the
+              currently-running Fuse.
+
+              Auto-load media
+                     On many occasions when you open a tape or disk file, it's
+                     because  it's  got a program in you want to load and run.
+                     If this option is selected, this will automatically  hap-
+                     pen  for  you  when you open one of these files using the
+                     File, Open...  menu option -- you must then use the Media
+                     menu  to  use  tapes  or disks for saving data to, or for
+                     loading data into an already running program.
+
+              Detect loaders
+                     If this option is enabled, Fuse will  attempt  to  detect
+                     when a loading routine is in progress, and then automati-
+                     cally start the virtual tape to load the program in. This
+                     is  done  by using a heuristic to identify a loading rou-
+                     tine, so is by no means infallible,  but  works  in  most
+                     cases.
+
+              Phantom typist mode
+                     Specify  the keystroke sequence that the "phantom typist"
+                     should use when starting  a  program  loading.  Available
+                     options are
+
+                            Auto
+
+                            Keyword
+
+                            Keystroke
+
+                            Menu
+
+                            Plus 2A
+
+                            Plus 3
+
+                     The first four of these correspond to automatic detection
+                     based on machine model, keyword  based  entry,  keystroke
+                     based  entry, and selection from a 128K style menu.  Plus
+                     2A and Plus 3 also correspond to selection  from  a  128K
+                     style  menu,  but  have  special handling for games which
+                     need to be loaded with `LOAD ""CODE'. The most likely use
+                     for this option will be use Keystroke if you have changed
+                     the default 48K ROM for one with keystroke entry.
+
+              Fastloading
+                     If this option is enabled, then  Fuse  will  run  at  the
+                     fastest  possible speed when the virtual tape is playing,
+                     thus dramatically reducing the time it takes to load pro-
+                     grams. You may wish to disable this option if you wish to
+                     stop the tape at a specific point.
+
+              Use tape traps
+                     Ordinarily, Fuse intercepts calls to the ROM tape-loading
+                     routine  in  order  to  load from tape files more quickly
+                     when possible. But this can (rarely) interfere  with  TZX
+                     loading;  disabling this option avoids the problem at the
+                     cost of  slower  (i.e.  always  real-time)  tape-loading.
+                     When  tape-loading  traps are disabled, you need to start
+                     tape playback manually, by pressing F8  or  choosing  the
+                     Media, Tape, Play menu item. Fuse also uses tape traps to
+                     intercept the tape-saving routine in the ROM to save tape
+                     files  quickly,  tapes can also be saved using the Media,
+                     Tape, Record Start menu item.
+
+              Accelerate loaders
+                     If this option is enabled,  then  Fuse  will  attempt  to
+                     accelerate tape loaders by "short circuiting" the loading
+                     loop. This will in general  speed  up  loading,  but  may
+                     cause some loaders to fail.
+
+              Use .slt traps
+                     The  multi-load  aspect  of  SLT  files  requires  a trap
+                     instruction to be supported. This instruction is not gen-
+                     erally  used  except  for  this  trap, but since it's not
+                     inconceivable that a program could be wanting to use  the
+                     real  instruction instead, you can choose whether to sup-
+                     port the trap or not.
+
+              MDR cartridge len
+                     This option controls the number of blocks in a new Micro-
+                     drive cartridge.  If the value smaller than 10 or greater
+                     than 254 Fuse assumes 10 or 254.  Average  real  capacity
+                     is around 180 blocks (90 Kb).
+
+              Random length MDR cartridge
+                     If  this option is enabled, Fuse will use a random Micro-
+                     drive cartridge length (around 180 blocks) instead of the
+                     length specified in the MDR cartridge len option.
+
+       Options, Sound...
+              Display  the  Sound Options dialog, letting you configure Fuse's
+              sound output. (With the widget UI, the keys  shown  in  brackets
+              toggle the options, Enter confirms any changes, and Esc aborts).
+              Note that any changed settings only apply to the  currently-run-
+              ning Fuse.
+
+              Sound enabled
+                     Specify  whether  sound  output should be enabled at all.
+                     When this option is disabled,  Fuse  will  not  make  any
+                     sound.
+
+              Loading sound
+                     Normally,  Fuse  emulates tape-loading noise when loading
+                     from PZXs, TAPs or TZXs in real-time, albeit at a  delib-
+                     erately  lower  volume  than  on a real Spectrum. You can
+                     disable  this  option  to  eliminate  the  loading  noise
+                     entirely.
+
+              AY stereo separation
+                     By  default,  the sound output is mono, since this is all
+                     you got from an unmodified Spectrum.  But  enabling  this
+                     option gives you so-called ACB stereo (for sound from the
+                     128 and other clone's AY-3-8912 sound chip).
+
+              Force 8-bit
+                     Force the use of 8-bit sound even if 16-bit (the default)
+                     is  available.  Note that (when the option is enabled) if
+                     8-bit sound isn't available then there will be  no  sound
+                     at  all,  so  it's best not to use this option unless you
+                     have a specific need for it.
+
+              Speaker type
+                     This option allows the emulation of the sound output sys-
+                     tem  to  be  modified. Different choices of speaker limit
+                     the bass and treble response that can  be  produced  from
+                     the  machine.  Choose  between  a "TV" type speaker and a
+                     small "Beeper" type  speaker  that  significantly  limits
+                     bass  and  treble  response.  Choose  "Unfiltered" to get
+                     unmodified (but less accurate) sound output.
+
+              AY volume
+                     Sets the relative volume of the  AY-3-8912  chip  from  a
+                     range of 0-100%.
+
+              Beeper volume
+                     Sets  the  relative  volume of the beeper from a range of
+                     0-100%.
+
+              Covox volume
+                     Sets the relative volume of the Covox  from  a  range  of
+                     0-100%.
+
+              SpecDrum volume
+                     Sets  the relative volume of the SpecDrum from a range of
+                     0-100%.
+
+       Options, Peripherals, General...
+              Display the General Peripherals Options dialog, letting you con-
+              figure  the  peripherals which Fuse will consider to be attached
+              to the emulated machine. (With the widget UI, the keys shown  in
+              brackets toggle the options, Enter confirms any changes, and Esc
+              aborts). Note that any changed settings only apply to  the  cur-
+              rently-running  Fuse. Also note that any changes that enable and
+              disable peripherals may result in a hard reset of  the  emulated
+              machine.
+
+              Kempston joystick
+                     If  this option is selected, Fuse will emulate a Kempston
+                     joystick interface (probably the  most  widely  supported
+                     type  on  the  Spectrum).  Note that this option is basi-
+                     cally equivalent to plugging the interface itself into  a
+                     Spectrum,  not to connecting a joystick; this affects how
+                     the Spectrum responds to a read of input port 31. To  use
+                     a  Kempston  joystick  in  a  game,  this  option must be
+                     enabled, and you must also select a Kempston joystick the
+                     Options, Joysticks menu.
+
+              Kempston mouse
+                     If  this option is selected, Fuse will emulate a Kempston
+                     mouse interface.
+
+                     If you're using Fuse full-screen, your mouse is automati-
+                     cally used as if attached to the Kempston interface. Oth-
+                     erwise, you'll need to click on the Spectrum  display  in
+                     order  to  tell  Fuse  to  grab  the pointer (and make it
+                     invisible); to tell Fuse to release it, click the  middle
+                     button (or wheel) or press Escape.
+
+                     With the framebuffer UI, Fuse prefers to use GPM; if this
+                     is not available, it will  fall  back  to  built-in  PS/2
+                     mouse  support.  In  this mode, it tries /dev/input/mice,
+                     /dev/mouse then /dev/psaux, stopping when it successfully
+                     opens  one.  The  first  of  these is preferred since (at
+                     least on Linux, with a 2.6-series  kernel)  any  type  of
+                     mouse can be used and any connected mouse may be used.
+
+              Swap mouse buttons
+                     If  this option is enabled, the left and right mouse but-
+                     tons will be swapped when emulating a Kempston mouse.
+
+              Fuller Box
+                     If this option is selected, Fuse will  emulate  a  Fuller
+                     Box  AY  sound  and joystick interface. This emulation is
+                     only available for the 16k, 48k and TC2048 machines.
+
+              Melodik
+                     If this option is selected, Fuse will emulate  a  Melodik
+                     AY  sound  interface.   These interfaces and many similar
+                     ones were produced to make  the  48K Spectrum  compatible
+                     with  the same AY music as the 128K Spectrum. This emula-
+                     tion is only  available  for  the  16k,  48k  and  TC2048
+                     machines.
+
+              Interface 1
+                     If  this option is selected, Fuse will emulate the simple
+                     Sinclair Interface 1, and allow Microdrive cartridges  to
+                     be connected and disconnected via the Media, Interface 1,
+                     Microdrive menus. It also enables support for the  Inter-
+                     face 1 RS-232 interface.
+
+              Interface 2
+                     If this option is selected, Fuse will emulate a cartridge
+                     port as found on the Interface 2. Cartridges can then  be
+                     inserted  and  removed  via  the Media, Cartridge, Inter-
+                     face 2 menu. Note that  the  Pentagon,  Scorpion,  Inter-
+                     face 2, ZXATASP and ZXCF all use the same hardware mecha-
+                     nism for accessing some of their  extended  features,  so
+                     only  one  of  these should be selected at once or unpre-
+                     dictable behaviour will occur.
+
+              Multiface One
+                     If this option is selected, Fuse will emulate the  Roman-
+                     tic  Robot  Multiface One.   Available  for  16K, 48K and
+                     Timex TC2048 machines.
+
+              Multiface 128
+                     If this option is selected, Fuse will emulate the  Roman-
+                     tic  Robot  Multiface 128.  Available for 16K, 48K, Timex
+                     TC2048, 128K, +2 and SE machines.
+
+              Multiface 3
+                     If this option is selected, Fuse will emulate the  Roman-
+                     tic  Robot  Multiface 3.  Available  for  +2A, +3 and +3e
+                     machines.
+
+              Stealth Multiface One
+                     This option controls the `invisible' or `stealth' mode of
+                     Multiface  One, as the physical switch on the side of the
+                     interface.
+
+              Emulate printers
+                     If this option is selected, Fuse will emulate a  printer.
+                     See the PRINTER EMULATION section for more details.
+
+              ZX Printer
+                     If  this  option  is  selected,  Fuse will emulate the ZX
+                     Printer. See  the  PRINTER  EMULATION  section  for  more
+                     details.
+
+              SpeccyBoot interface
+                     If  this  option is selected, Fuse will emulate a Speccy-
+                     Boot interface which allows booting a ZX Spectrum over an
+                     Ethernet   network.   See  the  SpeccyBoot  web  page  at
+                     http://patrikpersson.github.io/speccyboot/    for    more
+                     details.
+
+              SpecDrum interface
+                     If  this  option is selected, Fuse will emulate a Cheetah
+                     SpecDrum sound interface.   See  the  World  of  Spectrum
+                     Infoseek     web    page    at    http://www.worldofspec-
+                     trum.org/infoseekid.cgi?id=1000062 for manuals,  software
+                     and  more.  This emulation is only available for the 48k,
+                     128k and TC2048 machines.
+
+              Spectranet
+                     If this option is selected, Fuse will emulate  the  Spec-
+                     tranet  interface,  which  provides an Ethernet interface
+                     for the Spectrum. See the  SPECTRANET  EMULATION  section
+                     for more details.
+
+              Spectranet disable
+                     This  option  controls  the state of the Spectranet auto-
+                     matic page-in jumper (J2). See the  SPECTRANET  EMULATION
+                     section for more details.
+
+              Source
+                     If  this  option  is selected, Fuse will emulate a Currah
+                     Source interface.  See the World of Spectrum Infoseek web
+                     page       at       http://www.worldofspectrum.org/infos-
+                     eekid.cgi?id=1000080 for the manual.
+
+              Covox interface
+                     If this option is selected, Fuse  will  emulate  a  Covox
+                     digital sound interface. This emulation is only available
+                     for the Pentagon, Pentagon 512k, Pentagon 1024k and Scor-
+                     pion  machines.  The  Pentagon variants use port 0xfb and
+                     the Scorpion version uses port 0xdd.
+
+       Options, Peripherals, Disk...
+              Display the Disk Peripherals Options dialog, letting you config-
+              ure  the  disk interface peripherals which Fuse will consider to
+              be attached to the emulated machine. (With the  widget  UI,  the
+              keys  shown  in  brackets toggle the options, Enter confirms any
+              changes, and Esc aborts). Note that any  changed  settings  only
+              apply  to the currently-running Fuse. Also note that any changes
+              that enable and disable peripherals may result in a  hard  reset
+              of the emulated machine.
+
+              Simple 8-bit IDE
+                     If  this option is selected, Fuse will emulate the simple
+                     8-bit IDE interface as  used  by  the  Spectrum +3e,  and
+                     allow hard disks to be connected and disconnected via the
+                     Media, IDE, Simple 8-bit menu.
+
+              ZXATASP interface
+                     If this option is selected, Fuse will emulate the ZXATASP
+                     interface,  which provides both additional RAM and an IDE
+                     interface. See the ZXATASP  AND  ZXCF  section  for  more
+                     details.
+
+              ZXATASP upload
+                     This  option  controls  the  state  of the ZXATASP upload
+                     jumper.  See  the  ZXATASP  AND  ZXCF  section  for  more
+                     details.
+
+              ZXATASP write protect
+                     This  option controls the state of the ZXATASP write pro-
+                     tect jumper. See the ZXATASP AND ZXCF  section  for  more
+                     details.
+
+              ZXCF interface
+                     If  this  option  is selected, Fuse will emulate the ZXCF
+                     interface, which provides both additional RAM and a  Com-
+                     pactFlash interface. See the ZXATASP AND ZXCF section for
+                     more details.
+
+              ZXCF upload
+                     This option controls the state of the ZXCF upload jumper.
+                     See the ZXATASP AND ZXCF section for more details.
+
+              ZXMMC interface
+                     If  this  option is selected, Fuse will emulate the ZXMMC
+                     interface.  Available for +2A, +3 and +3e machines.
+
+              DivIDE interface
+                     If this option is selected, Fuse will emulate the  DivIDE
+                     interface. See the DIVIDE section for more details.
+
+              DivIDE write protect
+                     This  option  controls the state of the DivIDE write pro-
+                     tection jumper. See the DIVIDE section for more details.
+
+              DivMMC interface
+                     If this option is selected, Fuse will emulate the  DivMMC
+                     interface. See the DIVMMC section for more details.
+
+              DivMMC write protect
+                     This  option  controls the state of the DivMMC write pro-
+                     tection jumper that prevents flashing  the  EEPROM  chip.
+                     See the DIVMMC section for more details.
+
+              +D interface
+                     If  this  option  is  selected,  Fuse will emulate the +D
+                     interface.   See  the  +D  EMULATION  section  for   more
+                     details.
+
+              Didaktik 80 interface
+                     If  this option is selected, Fuse will emulate the Didak-
+                     tik 80 (or Didaktik 40) interface.  See  the  DIDAKTIK 80
+                     EMULATION section for more details.
+
+              DISCiPLE interface
+                     If  this option is selected, Fuse will emulate the DISCi-
+                     PLE interface.  See the DISCIPLE  EMULATION  section  for
+                     more details.
+
+              Beta 128 interface
+                     If  this  option  is  selected,  Fuse  will  emulate  the
+                     Beta 128 interface.  See the BETA 128  EMULATION  section
+                     for  more  details. Beta 128 emulation is enabled for the
+                     Pentagon and Scorpion machines regardless of this option.
+
+              Beta 128 auto-boot in 48K machines
+                     If this option is selected, then when a  Beta 128  inter-
+                     face is used in 48K or TC2048 emulation, the machine will
+                     boot directly into the TR-DOS system.
+
+              Opus Discovery interface
+                     If this option is selected, Fuse will  emulate  the  Opus
+                     Discovery  interface.   See  the OPUS DISCOVERY EMULATION
+                     section for more details.
+
+       Options, RZX...
+              Display the RZX Options dialog, letting you configure how Fuse's
+              deals  with  RZX input recordings. (With the widget UI, the keys
+              shown  in  brackets  toggle  the  options,  Enter  confirms  any
+              changes,  and  Esc  aborts). Note that any changed settings only
+              apply to the currently-running Fuse.
+
+              Create autosaves
+                     If this option is selected, Fuse will add a snapshot into
+                     the  recording  stream  every 5 seconds while creating an
+                     RZX file, thus enabling the  rollback  facilities  to  be
+                     used  without having to explicitly add snapshots into the
+                     stream. Older snapshots will be pruned from the stream to
+                     keep  the  file  size  and number of snapshots down: each
+                     snapshot up to 15 seconds will be kept, then one snapshot
+                     every  15 seconds  until  one  minute,  then one snapshot
+                     every minute until 5 minutes, and then one snapshot every
+                     5 minutes. Note that this "pruning" applies only to auto-
+                     matically inserted snapshots: snapshots manually inserted
+                     into the stream will never be pruned.
+
+              Compress RZX data
+                     If  this  option is selected, and zlib was available when
+                     Fuse was compiled, any RZX files written by Fuse will  be
+                     compressed.  This  is  generally a good thing as it makes
+                     the files significantly smaller, and you probably want to
+                     turn  it  off  only  if you're debugging the RZX files or
+                     there's some other program  which  doesn't  support  com-
+                     pressed RZX files.
+
+              Competition mode
+                     Any  input  recordings which are started when this option
+                     is selected  will  be  made  in  `competition  mode'.  In
+                     essence,  this  means that Fuse will act just like a real
+                     Spectrum would: you can't load snapshots, pause the  emu-
+                     lation  in any way, change the speed or anything that you
+                     couldn't do on the real machine. If any of  these  things
+                     are  attempted,  or  if the emulated Fuse is running more
+                     than 5% faster or slower than normal Spectrum speed, then
+                     the recording will immediately be stopped.
+
+                     If  libgcrypt  was available when Fuse was compiled, then
+                     recordings made with competition mode active will be dig-
+                     itally  signed,  in  theory to `certify' that it was made
+                     with the above restrictions in place.  However, this pro-
+                     cedure  is  not  secure  (and  cannot be made so), so the
+                     presence of any signature on an RZX file  should  not  be
+                     taken  as  providing proof that it was made with competi-
+                     tion mode active.   This  feature  is  included  in  Fuse
+                     solely  as  it was one of the requirements for Fuse to be
+                     used in an on-line tournament.
+
+              Competition code
+                     The numeric code entered here will be  written  into  any
+                     RZX  files made in competition mode. This is another fea-
+                     ture for on-line tournaments which can be used to `prove'
+                     that  the  recording  was  made after a specific code was
+                     released. If you're not playing in such a tournament, you
+                     can safely ignore this option.
+
+              Always embed snapshot
+                     Specify  whether  a snapshot should be embedded in an RZX
+                     file when recording is started from an existing snapshot.
+
+       Options, Movie...
+              Display the Movie Options  dialog,  letting  you  configure  how
+              Fuse's deals with movie recordings.
+
+              Movie compression
+                     This  option  set the compression level to None, Lossless
+                     or High. (See the MOVIE RECORDING section for more infor-
+                     mation).
+
+              Stop recording after RZX ends
+                     If  this  option  is  selected,  Fuse will stop any movie
+                     recording after an RZX playback is finished.
+
+       Options, Joysticks
+              Fuse can emulate many of the common types of joystick which were
+              available  for  the  Spectrum. The input for these emulated joy-
+              sticks can be taken from real joysticks attached to the  emulat-
+              ing   machine  (configured  via  the  Options,  Joysticks,  Joy-
+              stick 1...  and Options, Joysticks, Joystick 2...  options),  or
+              from  the  q,  a, o, p, and Space keys on the emulating machines
+              keyboard, configured via  the  Options,  Joysticks,  Keyboard...
+              option. Note that when using the keyboard to emulate a joystick,
+              the q, a, o, p, and Space keys will not have their normal effect
+              (to  avoid  problems  with  games which do things like use p for
+              pause when using a joystick).
+
+              Each of the joysticks (including the `fake'  keyboard  joystick)
+              can  be  configured to emulate any one of the following joystick
+              types:
+
+                     None
+                            No joystick: any input will simply be ignored.
+
+                     Cursor
+                            A  cursor  joystick,  equivalent  to  pressing   5
+                            (left), 6 (down), 7 (up), 8 (right), and 0 (fire).
+
+                     Kempston
+                            A Kempston joystick, read from input port 31. Note
+                            that the Options, Peripherals,  General,  Kempston
+                            interface option must also be set for the input to
+                            be recognised.
+
+                     Sinclair 1
+                     Sinclair 2
+                            The `left' and `right' Sinclair joysticks, equiva-
+                            lent  to pressing 1 (left), 2 (right), 3 (down), 4
+                            (up), and 5 (fire), or  6  (left),  7  (right),  8
+                            (down), 9 (up), and 0 (fire) respectively.
+
+                     Timex 1
+                     Timex 2
+                            The  `left'  and  `right' joysticks as attached to
+                            the Timex 2068 variant's built-in joystick  inter-
+                            face.
+
+              For  the  real  joysticks, it is also possible to configure what
+              effect each button on the joystick will have: this can  be  Joy-
+              stick  Fire, equivalent to pressing the emulated joystick's fire
+              button, Nothing, meaning to have no effect, or any Spectrum key,
+              meaning that pressing that button will be equivalent to pressing
+              that Spectrum key.
+
+       Options, Select ROMs, Machine ROMs
+              An individual dialog is available for each Spectrum variant emu-
+              lated  by Fuse which allows selection of the ROM(s) used by that
+              machine. Simply select the ROM you wish to use, and  then  reset
+              the Spectrum for the change to take effect.
+
+       Options, Select ROMs, Peripheral ROMs
+              The  same  as the Machine ROMs menu, but an individual dialog is
+              available for peripherals that need a ROM. Simply select the ROM
+              you  wish  to use, and then reset the Spectrum for the change to
+              take effect.
+
+       Options, Filter...
+              Select the graphics filter currently in use.  See  the  GRAPHICS
+              FILTERS section for more details.
+
+       F11
+       Options, Full Screen
+              Switch Fuse between full screen and windowed mode.  This menu is
+              only available under the SDL UI.
+
+       Options, Disk Options...
+              When emulating disk drives, Fuse allows the specification of the
+              physical  drive  units  attached to the emulated interface. Each
+              drive can be set to be one of the following types:
+
+                     Disabled
+
+                     Single-sided 40 track
+
+                     Double-sided 40 track
+
+                     Single-sided 80 track
+
+                     Double-sided 80 track
+
+              The Disabled option is not supported for Drive 1 or Drive  A  of
+              any interface.
+
+              The available options that can be set are:
+
+              +3 Drive A
+                     Defaults to a single-sided 40 track drive.
+
+              +3 Drive B
+                     Defaults to a double-sided 80 track drive.
+
+              +3 Detect Speedlock
+                     Specify  whether  the  +3  drives try to detect Speedlock
+                     protected disks, and emulate `weak' sectors.  If the disk
+                     image  file (EDSK or UDI) contains weak sector data, than
+                     Speedlock detection is automatically omitted.   See  also
+                     the WEAK DISK DATA section.
+
+              Beta 128 Drive A
+                     Defaults to a double-sided 80 track drive.
+
+              Beta 128 Drive B
+                     Defaults to a double-sided 80 track drive.
+
+              Beta 128 Drive C
+                     Defaults to a double-sided 80 track drive.
+
+              Beta 128 Drive D
+                     Defaults to a double-sided 80 track drive.
+
+              +D Drive 1
+                     Defaults to a double-sided 80 track drive.
+
+              +D Drive 2
+                     Defaults to a double-sided 80 track drive.
+
+              Didaktik 80 Drive A
+                     Defaults to a double-sided 80 track drive.
+
+              Didaktik 80 Drive B
+                     Defaults to a double-sided 80 track drive.
+
+              DISCiPLE Drive 1
+                     Defaults to a double-sided 80 track drive.
+
+              DISCiPLE Drive 2
+                     Defaults to a double-sided 80 track drive.
+
+              Opus Drive 1
+                     Defaults to a single-sided 40 track drive.
+
+              Opus Drive 2
+                     Defaults to a single-sided 40 track drive.
+
+              Try merge 'B' side of disks
+                     This  option  prompts  the  user  to confirm whether Fuse
+                     should try to merge the `B' side of a disk image  from  a
+                     separate file when opening a new single-sided disk image.
+
+              Confirm merge disk sides
+                     Select  whether  Fuse should try to merge a separate file
+                     for the `B' side of a disk image separate file when open-
+                     ing  a  new disk image. Most double sided disk images are
+                     dumped as two single sided disk images e.g.  `Golden  Axe
+                     -  Side A.dsk'  and  `Golden Axe - Side B.dsk'. So, if we
+                     want to play Golden Axe, first  we  have  to  insert  the
+                     first disk image and when the game asks to insert side B,
+                     we have to find and open the second disk  image,  instead
+                     of just `flip'-ing the disk inside the drive. If enabled,
+                     Fuse will try to open the second image too and  create  a
+                     double  sided  disk image (merging the two one sided disk
+                     images) and insert this merged virtual disk into the disk
+                     drive.  The function detects whether the file is one side
+                     of a double-sided image if the filename matches a pattern
+                     like  [Ss]ide[ _][abAB12][ _.] in the file name of a disk
+                     that is being opened. If found, Fuse will try to open the
+                     other  side  of the disk too substituting the appropriate
+                     characters in the filename e.g.   1->2,  a->b,  A->B.  If
+                     successful  then  it will merge the two images and now we
+                     have a double sided disk in drive. This means that if  we
+                     open  `Golden  Axe  -  Side A.dsk', then Fuse will try to
+                     open `Golden Axe - Side B.dsk'  too.  Now,  we  can  just
+                     `flip'  the  disk  if  Golden Axe asks for `Side B'.  The
+                     available options are Never, With single-sided drives and
+                     Always.
+
+       Options, Save
+              This  will cause Fuse's current options to be written to .fuserc
+              in your home directory (Unix-like systems), or fuse.cfg in  your
+              %USERPROFILE%  folder  (Windows), from which they will be picked
+              up again when Fuse is restarted. The best  way  to  update  this
+              file  is  by  using  this  option, but it's a simple XML file if
+              libxml2 was available when Fuse was compiled  (otherwise,  plain
+              text),  and  shouldn't be too hard to edit by hand if you really
+              want to.
+
+       Pause
+       Machine, Pause
+              Pause or unpause emulation. This option is available only  under
+              the GTK+ and Win32 UIs; to pause the other user interfaces, sim-
+              ply press F1 to bring up the main menu.
+
+       F5
+       Machine, Reset
+              Reset the emulated Spectrum.
+
+       Machine, Hard reset
+              Reset the emulated Spectrum. A hard reset is equivalent to turn-
+              ing the Spectrum's power off, and then turning it back on.
+
+       F9
+       Machine, Select...
+              Choose  a  type of Spectrum to emulate. An brief overview of the
+              Sinclair,    Amstrad    and    Timex    can    be    found    at
+              http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspec-
+              trum.htm while  more  technical  information  can  be  found  at
+              http://www.worldofspectrum.org/faq/reference/reference.htm,  and
+              http://www.worldofspectrum.org/faq/reference/tmxreference.htm.
+
+              Spectrum 16K
+              Spectrum 48K
+                     The original machines as released  by  Sinclair  in  1982
+                     with 16 or 48K of RAM respectively.
+
+              Spectrum 48K (NTSC)
+                     The NTSC 48K machine released in limited numbers in parts
+                     of South America.
+
+              Spectrum 128K
+                     The 128K machine as released by Sinclair in  1985 (Spain)
+                     or 1986 (UK).
+
+              Spectrum +2
+                     The  first  machine released by Amstrad, in 1986. From an
+                     emulation point of view, the +2 is virtually identical to
+                     the 128K.
+
+              Spectrum +2A
+              Spectrum +3
+                     The two machines released by Amstrad in 1988. Technically
+                     very similar to each other, except that the +3 features a
+                     3 disk drive while the +2A does not.
+
+              Spectrum +3e
+                     A +3 with modified ROMs allowing access to IDE hard disks
+                     via the simple 8-bit interface,  as  activated  from  the
+                     Options,     Peripherals,     Disk...      dialog.    See
+                     http://www.worldofspectrum.org/zxplus3e/     for     more
+                     details.
+
+              Timex TC2048
+              Timex TC2068
+                     The variants of the Spectrum as released by Timex in Por-
+                     tugal.
+
+              Timex TS2068
+                     The variant of the Spectrum released by  Timex  in  North
+                     America.
+
+              Pentagon 128K
+                     Russian  clone of the Spectrum. There were many different
+                     machines called Pentagon from 1989 to 2006, this  machine
+                     corresponds to a 1991 era Pentagon 128K with the optional
+                     AY sound chip and the integrated Beta 128 disk interface,
+                     and  is  the  version of the machine most often emulated.
+                     More technical details can be found at  http://www.world-
+                     ofspectrum.org/rusfaq/index.html,
+
+              Pentagon 512K
+              Pentagon 1024K
+                     Newer  versions  of  the Pentagon Russian Spectrum clones
+                     which incorporate more memory and the "Mr Gluk Reset Ser-
+                     vice" ROM offering a more powerful firmware.
+
+              Scorpion ZS 256
+                     Another  Russian  clone of the Spectrum. Some details can
+                     be    found    at     http://www.worldofspectrum.org/rus-
+                     faq/index.html.   Like  all the Russian clones, they have
+                     built in 3.5 disk drives, accessed via the Beta 128  disk
+                     interface  and TR-DOS (the Technology Research Disk Oper-
+                     ating System). The most important  distinction  from  the
+                     Pentagon 128k  and similar machines is the display timing
+                     details.
+
+              Spectrum SE
+                     A recent  variant  designed  by  Andrew  Owen  and  Jarek
+                     Adamski,  which  is  possibly  best thought of as a cross
+                     between the 128K machine and the Timex variants, allowing
+                     272K  of RAM to be accessed. Some more details are avail-
+                     able     at     http://www.worldofspectrum.org/faq/refer-
+                     ence/sereference.htm  and  documentation  of the extended
+                     BASIC is available  at  https://github.com/cheveron/seba-
+                     sic4/wiki.    The   bug  tracker  for  the  BASIC  is  at
+                     https://github.com/cheveron/sebasic4/issues?state=open.
+
+       Machine, Debugger...
+              Start the monitor/debugger. See the MONITOR/DEBUGGER section for
+              more information.
+
+       Machine, Poke Finder...
+              Start  the  `poke  finder'. See the POKE FINDER section for more
+              information.
+
+       Machine, Poke Memory...
+              Allow one to use multiface POKEs for  things  such  as  infinite
+              lives. See the POKE MEMORY section for more information.
+
+       Machine, Memory Browser...
+              Start  the memory browser. It should be fairly obvious what this
+              does; perhaps the only thing worth noting is that  emulation  is
+              paused until you close the window.
+
+       Machine, NMI
+              Sends  a non-maskable interrupt to the emulated Spectrum. Due to
+              a typo in the standard 48K ROM, this will  cause  a  reset,  but
+              modified ROMs are available which make use of this feature. When
+              the +D (or DISCiPLE) is emulated, this is used to access the  +D
+              (or  DISCiPLE)'s  screenshot  and  snapshot features (see the +D
+              EMULATION and DISCIPLE EMULATION sections below).  For the  DIS-
+              CiPLE, Caps Shift must be held down whilst pressing the NMI but-
+              ton.  For some UIs, this may be tricky, or  even  impossible  to
+              do.   Note that GDOS on the DISCiPLE contains a bug which causes
+              corruption of saved snapshots, and a failure to return from  the
+              NMI menu correctly.  This bug is not present in G+DOS on the +D.
+
+       Machine, Multiface Red Button
+              Presses  the Multiface One/128/3 red button to active the inter-
+              face.
+
+       Machine, Didaktik SNAP
+              Presses the Didaktik 80 (or Didaktik 40)'s `SNAP' button.
+
+       F7
+       Media, Tape, Open...
+              Choose a PZX, TAP or TZX virtual-tape file to load from. See the
+              FILE  SELECTION  section  below for details on how to choose the
+              file. If Auto-load media is set in the Media Options dialog  (as
+              it  is  by  default), you may use the File, Open...  menu option
+              instead, and the tape will begin loading automatically.   Other-
+              wise,  you  have to start the load in the emulated machine (with
+              LOAD "" or the 128's Tape Loader option, though you may need  to
+              reset first).
+
+              To  guarantee  that  TZX  files  will  load properly, you should
+              select the file, make sure tape-loading traps  are  disabled  in
+              the  Media  Options  dialog,  then  press F8 (or do Media, Tape,
+              Play).  That said, most TZXs will work with  tape-loading  traps
+              enabled  (often  quickly  loading partway, then loading the rest
+              real-time), so you might want to try it that way first.
+
+       F8
+       Media, Tape, Play
+              Start playing the PZX, TAP or TZX file, if  required.  (Choosing
+              the option (or pressing F8) again pauses playback, and a further
+              press resumes). To explain -- if tape-loading  traps  have  been
+              disabled  (in  the  Media  Options dialog), starting the loading
+              process in the emulated machine isn't enough. You also  have  to
+              `press  play', so to speak :-), and this is how you do that. You
+              may also need to `press play' like this in certain other circum-
+              stances,  e.g. TZXs containing multi-load games may have a stop-
+              the-tape request (which Fuse obeys).
+
+       Media, Tape, Browse
+              Browse through the current tape. A brief display of each of  the
+              data  blocks on the current tape will appear, from which you can
+              select which block Fuse will play next. With the GTK+ UI, emula-
+              tion will continue while the browser is displayed; double-click-
+              ing on a block will select it. In the other  UIs,  emulation  is
+              paused and you can use the cursor keys and press Enter to select
+              it. If you decide you don't want to  change  block,  just  press
+              Escape.
+
+       Media, Tape, Rewind
+              Rewind  the  current  virtual tape, so it can be read again from
+              the beginning.
+
+       Media, Tape, Clear
+              Clear the current virtual tape. This is particularly useful when
+              you  want  a  `clean  slate' to add newly-saved files to, before
+              doing Media, Tape, Write...  (or F6).
+
+       F6
+       Media, Tape, Write...
+              Write the current virtual-tape contents to a TZX file. You  will
+              be  prompted  for  a filename. The virtual-tape contents are the
+              contents of the previously-loaded tape (if any has  been  loaded
+              since  you  last did a Media, Tape, Clear), followed by anything
+              you've saved from the emulated machine since.  These newly-saved
+              files  are  not  written  to any tape file until you choose this
+              option!
+
+       Media, Tape, Record Start
+              Starts directly recording the output from the emulated  Spectrum
+              to  the  current  virtual-tape.  This is useful when you want to
+              record using a non-standard ROM or from a custom  save  routine.
+              Most tape operations are disabled during recording. Stop record-
+              ing with the Media, Tape, Write...  menu option.
+
+       Media, Tape, Record Stop
+              Stops the direct recording and places the new recording into the
+              virtual-tape.
+
+       Media, Interface 1
+              Virtual  Microdrive  images  are accessible only when the Inter-
+              face 1 is active from the Options, Peripherals, General...  dia-
+              log.  Note  that any changes to the Microdrive image will not be
+              written to the file on disk until the appropriate save option is
+              used.
+
+       Media, Interface 1, Microdrive 1, Insert New
+              Insert  a  new  (unformatted) Microdrive cartridge into emulated
+              Microdrive 1.
+
+       Media, Interface 1, Microdrive 1, Insert...
+              Insert an existing  Microdrive  cartridge  image  into  emulated
+              Microdrive 1. You will be prompted for a filename.
+
+       Media, Interface 1, Microdrive 1, Eject
+              Eject  the  Microdrive  image  in Microdrive 1. If the image has
+              been modified, you will be asked as  to  whether  you  want  any
+              changes saved.
+
+       Media, Interface 1, Microdrive 1, Save
+              Save the Microdrive image in Microdrive 1.
+
+       Media, Interface 1, Microdrive 1, Save as...
+              Write  the  Microdrive image in Microdrive 1 to a file. You will
+              be prompted for a filename.
+
+       Media, Interface 1, Microdrive 1, Write protect, Enable
+              Enable the write protect tab for the image in Microdrive 1.
+
+       Media, Interface 1, Microdrive 1, Write protect, Disable
+              Disable the write protect tab for the image in Microdrive 1.
+
+       Media, Interface 1, Microdrive 2, ...
+       Media, Interface 1, Microdrive 3, ...
+       Media, Interface 1, Microdrive 4, ...
+       Media, Interface 1, Microdrive 5, ...
+       Media, Interface 1, Microdrive 6, ...
+       Media, Interface 1, Microdrive 7, ...
+       Media, Interface 1, Microdrive 8, ...
+              Equivalent options for the other emulated Microdrives.
+
+       Media, Interface 1, RS232, Plug RxD
+       Media, Interface 1, RS232, Unplug RxD
+       Media, Interface 1, RS232, Plug TxD
+       Media, Interface 1, RS232, Unplug TxD
+              Connect or disconnect a communication channels (FIFO or file) to
+              use as the RS-232 TxD or RxD wire.
+
+       Media, Disk
+              Virtual  floppy  disk images are accessible when emulating a +3,
+              +3e, Pentagon or Scorpion, or when the Beta 128, Opus Discovery,
+              +D,  Didaktik  or  DISCiPLE  interface options are enabled and a
+              machine compatible with the chosen interface is  selected.  (See
+              THE  .DSK  FORMAT, BETA 128 EMULATION, OPUS DISCOVERY EMULATION,
+              +D EMULATION, DIDAKTIK 80 EMULATION and DISCIPLE EMULATION  sec-
+              tions below for notes on the file formats supported).
+
+              Once again, any changes made to a disk image will not affect the
+              file which was `inserted' into the drive. If you do want to keep
+              any changes, use the appropriate `eject and write' option before
+              exiting Fuse.
+
+       Media, Disk, +3, Drive A:, Insert...
+              Insert a disk-image file to  read/write  in  the  +3's  emulated
+              drive A:.
+
+       Media, Disk, +3, Drive A:, Eject
+              Eject  the disk image currently in the +3's emulated drive A: --
+              or from the emulated machine's perspective, eject it. Note  that
+              any changes made to the image will not be saved.
+
+       Media, Disk, +3, Drive A:, Save
+              Save the disk image currently in the +3's drive A:.
+
+       Media, Disk, +3, Drive A:, Save as...
+              Save  the  current state of the disk image currently in the +3's
+              drive A: to a file. You will be prompted for a filename.
+
+       Media, Disk, +3, Drive B:, Insert...
+              As above, but for the +3's drive B:. Fuse emulates drive B: as a
+              second 3 drive.
+
+       Media, Disk, +3, Drive B:, Eject
+              As above, but for drive B:.
+
+       Media, Disk, +3, Drive B:, Save
+              As above, but for drive B:.
+
+       Media, Disk, +3, Drive B:, Save as...
+              As above, but for drive B:.
+
+       Media, Disk, Beta, Drive A:, Insert New
+              Insert a new (unformatted) disk into the emulated Beta drive A:.
+
+       Media, Disk, Beta, Drive A:, Insert...
+       Media, Disk, Beta, Drive A:, Eject
+       Media, Disk, Beta, Drive A:, Save
+       Media, Disk, Beta, Drive A:, Save as...
+              As above, but for the emulated Beta disk drive A:.
+
+       Media, Disk, Beta, Drive A:, Write protect, Enable
+              Enable the write protect tab for the image in Beta drive A:.
+
+       Media, Disk, Beta, Drive A:, Write protect, Disable
+              Disable the write protect tab for the image in Beta drive A:.
+
+       Media, Disk, Beta, Drive B:, ...
+       Media, Disk, Beta, Drive C:, ...
+       Media, Disk, Beta, Drive D:, ...
+              As  above,  but  for  the remaining emulated Beta disk interface
+              drives.
+
+       Media, Disk, Opus, Drive 1, Insert New
+       Media, Disk, Opus, Drive 1, Insert...
+       Media, Disk, Opus, Drive 1, Eject
+       Media, Disk, Opus, Drive 1, Save
+       Media, Disk, Opus, Drive 1, Save as...
+       Media, Disk, Opus, Drive 1, Write protect, Enable
+       Media, Disk, Opus, Drive 1, Write protect, Disable
+       Media, Disk, Opus, Drive 2, ...
+              As above, but for the emulated Opus Discovery drives.
+
+       Media, Disk, +D, Drive 1, Insert New
+       Media, Disk, +D, Drive 1, Insert...
+       Media, Disk, +D, Drive 1, Eject
+       Media, Disk, +D, Drive 1, Save
+       Media, Disk, +D, Drive 1, Save as...
+       Media, Disk, +D, Drive 1, Write protect, Enable
+       Media, Disk, +D, Drive 1, Write protect, Disable
+       Media, Disk, +D, Drive 2, ...
+              As above, but for the emulated +D drives.
+
+       Media, Disk, Didaktik 80, Drive A, Insert New
+       Media, Disk, Didaktik 80, Drive A, Insert...
+       Media, Disk, Didaktik 80, Drive A, Eject
+       Media, Disk, Didaktik 80, Drive A, Save
+       Media, Disk, Didaktik 80, Drive A, Save as...
+       Media, Disk, Didaktik 80, Drive A, Write protect, Enable
+       Media, Disk, Didaktik 80, Drive A, Write protect, Disable
+       Media, Disk, Didaktik 80, Drive B, ...
+              As above, but for the emulated Didaktik 80 drives.
+
+       Media, Disk, DISCiPLE, Drive 1, Insert New
+       Media, Disk, DISCiPLE, Drive 1, Insert...
+       Media, Disk, DISCiPLE, Drive 1, Eject
+       Media, Disk, DISCiPLE, Drive 1, Save
+       Media, Disk, DISCiPLE, Drive 1, Save as...
+       Media, Disk, DISCiPLE, Drive 1, Write protect, Enable
+       Media, Disk, DISCiPLE, Drive 1, Write protect, Disable
+       Media, Disk, DISCiPLE, Drive 2, ...
+              As above, but for the emulated DISCiPLE drives.
+
+       Media, Cartridge, Timex Dock, Insert...
+              Insert a cartridge into the Timex 2068 dock. This will cause the
+              emulated  machine  to  be  changed  to  the TC2068 (if it wasn't
+              already a 2068 variant) and reset.
+
+       Media, Cartridge, Timex Dock, Eject
+              Remove the cartridge from the Timex 2068 dock. This  will  cause
+              the emulated machine to be reset.
+
+       Media, Cartridge, Interface 2, Insert...
+              Insert  a  cartridge  into  the Interface 2 cartridge slot. This
+              will cause the emulated machine to be reset  and  the  cartridge
+              loaded.
+
+       Media, Cartridge, Interface 2, Eject...
+              Remove  the  cartridge from the Interface 2 cartridge slot. This
+              will cause the emulated machine to be reset.
+
+       Media, IDE, Simple 8-bit, Master, Insert...
+              Connect an IDE hard disk to the simple 8-bit interface's  master
+              channel.
+
+       Media, IDE, Simple 8-bit, Master, Commit
+              Cause  any  writes  which  have  been  done to virtual hard disk
+              attached to the simple 8-bit interface's master  channel  to  be
+              committed  to  the real disk, such that they survive the virtual
+              disk being ejected.
+
+       Media, IDE, Simple 8-bit, Master, Eject
+              Eject the virtual hard disk from the  simple  8-bit  interface's
+              master  channel.  Note  that any writes to the virtual hard disk
+              will be lost unless the Media, IDE, Simple 8-bit, Master, Commit
+              option is used before the disk is ejected.
+
+       Media, IDE, Simple 8-bit, Slave, Insert...
+       Media, IDE, Simple 8-bit, Slave, Commit
+       Media, IDE, Simple 8-bit, Slave, Eject
+              The  same as the Media, IDE, Simple 8-bit, Master entries above,
+              but for the simple 8-bit interface's slave channel.
+
+       Media, IDE, ZXATASP, Master, Insert...
+       Media, IDE, ZXATASP, Master, Commit
+       Media, IDE, ZXATASP, Master, Eject
+       Media, IDE, ZXATASP, Slave, Insert...
+       Media, IDE, ZXATASP, Slave, Commit
+       Media, IDE, ZXATASP, Slave, Eject
+              The same as the Media, IDE, Simple 8-bit, Master entries  above,
+              but for the two channels of the ZXATASP interface.
+
+       Media, IDE, ZXCF CompactFlash, Insert...
+       Media, IDE, ZXCF CompactFlash, Commit
+       Media, IDE, ZXCF CompactFlash, Eject
+              The  same as the Media, IDE, Simple 8-bit, Master entries above,
+              but for the ZXCF interface's CompactFlash slot.
+
+       Media, IDE, ZXMMC, Insert...
+       Media, IDE, ZXMMC, Commit
+       Media, IDE, ZXMMC, Eject
+              The same as the Media, IDE, Simple 8-bit entries above, but  for
+              the memory card slot of the ZXMMC interface.
+
+       Media, IDE, DivIDE, Master, Insert...
+       Media, IDE, DivIDE, Master, Commit
+       Media, IDE, DivIDE, Master, Eject
+       Media, IDE, DivIDE, Slave, Insert...
+       Media, IDE, DivIDE, Slave, Commit
+       Media, IDE, DivIDE, Slave, Eject
+              The  same as the Media, IDE, Simple 8-bit entries above, but for
+              the two channels of the DivIDE interface.
+
+       Media, IDE, DivMMC, Insert...
+       Media, IDE, DivMMC, Commit
+       Media, IDE, DivMMC, Eject
+              The same as the Media, IDE, Simple 8-bit entries above, but  for
+              the memory card slot of the DivMMC interface.
+
+       Help, Keyboard...
+              Display a diagram showing the Spectrum keyboard, and the various
+              keywords that can be generated with each key from  (48K)  BASIC.
+              Under  the  GTK+  and  Win32 UIs, this will appear in a separate
+              window and emulation continues. With the other UIs, the  picture
+              remains  onscreen  (and the emulator paused) until you press Esc
+              or Enter.
+
+       Help, About...
+              Show Fuse's version number.
+
+KEY MAPPINGS
+       When emulating the Spectrum, keys F1 to F10 are used as  shortcuts  for
+       various  menu  items,  as described above. The alphanumeric keys (along
+       with Enter and Space) are mapped as-is to the Spectrum keys. The  other
+       key mappings are:
+
+       Shift  emulated as Caps Shift
+
+       Control, Alt, and Meta
+              emulated  as  Symbol Shift (most other modifiers are also mapped
+              to this)
+
+       Backspace
+              emulated as Caps-0 (Delete)
+
+       Esc    emulated as Caps-1 (Edit)
+
+       Caps Lock
+              emulated as Caps-2
+
+       Cursor keys
+              emulated as Caps-5/6/7/8 (as appropriate)
+
+       Tab    emulated as Caps Shift-Symbol Shift (Extended Mode)
+
+       Some further punctuation keys are supported, if they exist on your key-
+       board  -- `,', `.', `/', `;', `'', `#', `-', and `='.  These are mapped
+       to the appropriate symbol-shifted keys on the Spectrum.
+
+       A list of keys applicable when using  the  file  selection  dialogs  is
+       given in the FILE SELECTION section below.
+
+DISPLAY SIZE
+       Some  of  Fuse's UIs allow resizing of the emulated Spectrum's display.
+       For the window-based ones (GTK+, Win32 and Xlib), you  can  resize  the
+       window  by,  well,  resizing  it. :-) Exactly how this works depends on
+       your window manager; you may have to make the  window  over  twice  the
+       width  and  height  of  the original size before it actually scales up.
+       Fuse attempts to keep the window `square', but with  some  window  man-
+       agers this can mean the window will never resize at all. If you experi-
+       ence this problem, the `--no-aspect-hint' option may help.
+
+       If you're using the SDL UI under X11 or GTK+, the window will automati-
+       cally resize to be the correct size for the graphics filter selected.
+
+GRAPHICS FILTERS
+       Fuse  has  the  ability  to apply essentially arbitrary filters between
+       building its image of the Spectrum's screen, and displaying it  on  the
+       emulating  machine's  monitor.  These filters can be used to do various
+       forms of smoothing, emulation of TV scanlines and various other  possi-
+       bilities.  Support  for  graphics  filters varies between the different
+       user interfaces, but there are two general classes:  the  GTK+,  Win32,
+       Xlib,  SVGAlib  and SDL user interfaces (and the saving of .png screen-
+       shots) support `interpolating' filters which use a palette larger  than
+       the  Spectrum's  16 colours,  while the framebuffer user interface cur-
+       rently does not support filters at all.
+
+       A further complication arises due to the fact that the  Timex  machines
+       have their high-resolution video mode with twice the horizontal resolu-
+       tion. To deal with this, Fuse treats these machines as having  a  `nor-
+       mal'  display  size  which  is  twice  the  size of a normal Spectrum's
+       screen, leading to a different set of filters being available for these
+       machines.  Note  that  any  of  the double or triple-sizing filters are
+       available for Timex machines only when using the  SDL,  Win32  or  GTK+
+       user interfaces.
+
+       The  available filters, along with their short name used to select them
+       from the command line, are:
+
+       Timex half (smoothed) (half)
+       Timex half (skipping) (halfskip)
+              Two Timex-machine specific filters which scale the  screen  down
+              to  half normal (Timex) size; that is, the same size as a normal
+              Spectrum screen. The difference between these two filters is  in
+              how they handle the high-resolution mode: the `smoothed' version
+              is an interpolating filter which averages pairs of adjacent pix-
+              els,  while the `skipping' version is a non-interpolating filter
+              which simply drops every other pixel.
+
+       Normal (normal)
+              The simplest filter: just display one pixel for every  pixel  on
+              the Spectrum's screen.
+
+       Double size (2x)
+              Scale the displayed screen up to double size.
+
+       Triple size (3x)
+              Scale  the  displayed  screen  up to triple size. Available only
+              with the GTK+, Win32, Xlib and SDL user interfaces or when  sav-
+              ing screenshots of non-Timex machines.
+
+       Quadruple size (4x)
+              Scale  the displayed screen up to quadruple size. Available only
+              with the GTK+, Win32 and SDL user interfaces.
+
+       2xSaI (2xsai)
+       Super 2xSaI (super2xsai)
+       SuperEagle (supereagle)
+              Three  interpolating  filters  which  apply  successively   more
+              smoothing. All three double the size of the displayed screen.
+
+       AdvMAME2x (advmame2x)
+              A  double-sizing,  non-interpolating  filter  which  attempts to
+              smooth diagonal lines.
+
+       AdvMAME3x (advmame3x)
+              Very similar to AdvMAME2x, except that it triples  the  size  of
+              the  displayed screen. Available only with the GTK+, Win32, Xlib
+              and SDL user interfaces or when saving screenshots of  non-Timex
+              machines.
+
+       TV 2x (tv2x)
+       TV 3x (tv3x)
+       TV 4x (tv4x)
+       Timex TV (timextv)
+              Four  filters  which attempt to emulate the effect of television
+              scanlines. The first is a  double-sizing  filter  for  non-Timex
+              machines,  the  second  is  a  similar triple-sizing filter, the
+              third is a similar quadruple-sizing filter, while the last is  a
+              single-sizing  filter  for  Timex machines (note that this means
+              TV 2X and Timex TV produce the same size output).
+
+       PAL TV (paltv)
+       PAL TV 2x (paltv2x)
+       PAL TV 3x (paltv3x)
+              Three filters which attempt to emulate the effect of the PAL  TV
+              system which layers a lower-resolution colour image over the top
+              of a higher-resolution black-and-white image.  The  filters  can
+              also optionally add scanlines like the other TV series scalers.
+
+       Dot matrix (dotmatrix)
+              A double-sizing filter which emulates the effect of a dot-matrix
+              display.
+
+       Timex 1.5x (timex15x)
+              An interpolating Timex-specific filter which  scales  the  Timex
+              screen up to 1.5x its usual size (which is therefore 3x the size
+              of a `normal' Spectrum screen). Available  only  for  the  GTK+,
+              Win32 and SDL user interfaces or when saving screenshots.
+
+       Timex 2x (timex2x)
+              A non-interpolating Timex-specific filter which scales the Timex
+              screen up to 2x its usual size (which is therefore 4x  the  size
+              of  a  `normal'  Spectrum  screen). Available only for the GTK+,
+              Win32 and SDL user interfaces or when saving screenshots.
+
+       HQ 2x (hq2x)
+       HQ 3x (hq3x)
+       HQ 4x (hq4x)
+              Three filters which do high  quality  (but  slow)  antialiasing.
+              Doubles  and  triples  and  quadruples the size of the displayed
+              screen respectively.
+
+THE EMULATED SPECTRUM
+       The emulated Spectrum is, by default, an unmodified 48K Spectrum with a
+       tape  player  and  ZX Printer attached. Oh, and apparently some magical
+       snapshot load/save machine which is probably best glossed over for  the
+       sake of the analogy. :-)
+
+       To  emulate  different kinds of Spectrum, select the Machine, Select...
+       menu option, or press F9.
+
+       The Spectrum emulation is paused when any dialogs appear. In the widget
+       UI, it's also paused when menus or the keyboard picture are displayed.
+
+PRINTER EMULATION
+       The  various  models  of  Spectrum supported a range of ways to connect
+       printers, three of which are supported by Fuse. Different printers  are
+       made available for the different models:
+
+       16, 48, TC2048, TC2068, TS2068
+              ZX Printer
+
+       128/+2/Pentagon
+              Serial printer (text-only)
+
+       +2A, +3
+              Parallel printer (text-only)
+
+       If  Opus Discovery, +D or DISCiPLE emulation is in use and printer emu-
+       lation is enabled, text-only emulation of the disk interface's parallel
+       printer interface is provided.
+
+       Any  printout  is  appended to one (or both) of two files, depending on
+       the printer -- these default  to  printout.txt  for  text  output,  and
+       printout.pbm for graphics (PBM images are supported by most image view-
+       ers and converters). These names can be changed with the --textfile and
+       --graphicsfile  options  from  the  command line or configuration file.
+       While the ZX Printer can only output graphically, simulated text output
+       is  generated  at  the same time using a crude sort of OCR based on the
+       current character set (a bit like using SCREEN$). There is currently no
+       support  for graphics when using the serial/parallel output, though any
+       escape codes used will be `printed' faithfully. (!)
+
+       By the way, it's not a good idea to modify the printout.pbm  file  out-
+       side  of Fuse if you want to continue appending to it. The header needs
+       to have a certain layout for Fuse to be able to continue  appending  to
+       it  correctly, and the file will be overwritten if it can't be appended
+       to.
+
+ZXATASP AND ZXCF
+       The ZXATASP and ZXCF interfaces are two peripherals  designed  by  Sami
+       Vehmaa  which  significantly  extend  the capabilities of the Spectrum.
+       More  details   on   both   are   available   from   Sami's   homepage,
+       http://user.tninet.se/~vjz762w/, but a brief overview is given here.
+
+       The  real ZXATASP comes with either 128K or 512K of RAM and the ability
+       to connect an IDE hard disks and a CompactFlash card,  while  the  ZXCF
+       comes with 128K, 512K or 1024K of RAM and the ability to connect a Com-
+       pactFlash card. From an emulation point of view, the two interfaces are
+       actually  very  similar as a CompactFlash card is logically just an IDE
+       hard disk. Currently, Fuse's emulation is fixed at having 512K  of  RAM
+       in the ZXATASP and 1024K in the ZXCF.
+
+       To  activate  the  ZXATASP,  simply select the ZXATASP interface option
+       from the Options, Peripherals, Disk...  dialog. The state of the upload
+       and  write protect jumpers is then controlled by the ZXATASP upload and
+       ZXATASP write protect options. Similarly, the ZXCF is controlled by the
+       ZXCF interface and ZXCF upload options (the ZXCF write protect is soft-
+       ware controlled).
+
+       If you're using either the ZXATASP or ZXCF, you almost  certainly  want
+       to  investigate ResiDOS, the operating system designed for use with the
+       ZXATASP and ZXCF. ResiDOS provides facilities for using the extra  RAM,
+       accessing  the  mass storage devices and a task manager allowing virtu-
+       ally  instant  switching  between  programs  on   the   Spectrum.   See
+       http://www.worldofspectrum.org/residos/ for more details.
+
+DIVIDE
+       The  DivIDE  is  another  IDE interface for the Spectrum, of which full
+       details       can       be        found        at        http://web.ar-
+       chive.org/web/20150302052256/http://baze.au.com/divide/.  The interface
+       can be activated via the DivIDE  interface  option  from  the  Options,
+       Peripherals, Disk...  dialog, and the state of its write protect jumper
+       controlled via the DivIDE write protect option.  If you're going to  be
+       using  the  DivIDE, you'll probably want one of the firmwares available
+       from the DivIDE homepage.
+
+DIVMMC
+       The DivMMC is a MMC interface for the Spectrum. Originally designed  by
+       Alessandro Dorigatti for the V6Z80P+ FPGA board as the fusion of DivIDE
+       and ZXMMC+ interfaces, later assembled as an interface for  real  spec-
+       trums  by  Mario Prato. Currently there are variants with different RAM
+       size, one/two memory cards slots, optional kempston jostick, etc.
+
+       The interface can be activated via the DivMMC interface option from the
+       Options,  Peripherals,  Disk...   dialog,  and  the state of its EEPROM
+       write protect jumper controlled via the DivMMC  write  protect  option.
+       If  you're going to be using the DivMMC, you'll need to load the ESXDOS
+       firmware at http://www.esxdos.org/ or use the ZX Spectrum +3e  ROMs  by
+       Garry Lancaster.
+
+       You'll  also need a HDF image to store the contents of the memory card.
+       There are several tools to create  and  manipulate  this  file  format,
+       e.g., hdfmonkey at https://github.com/gasman/hdfmonkey.
+
+SPECTRANET EMULATION
+       The  Spectranet is an Ethernet network interface for the ZX Spectrum by
+       Dylan Thomas. The interface can be activated via the Spectranet  option
+       on  the  Peripherals preferences dialog, and the state of its automatic
+       page-in (disable) jumper controlled via the Spectranet disable  option.
+       If you're going to be using the Spectranet, you'll probably want one of
+       the firmwares available  from  the  Spectranet  homepage  (http://spec-
+       trum.alioth.net/doc/index.php)  which  is  also where you can find more
+       information on using the interface.
+
+       Installing the Spectranet firmware on Fuse is slightly more complicated
+       than on a real machine, mostly because Fuse's emulation doesn't support
+       DHCP. These instructions are correct as  of  2012-01-26  --  if  you're
+       using a later firmware than this, things may have changed slightly.
+
+       The  first  thing  you will need to do is to obtain a copy of the Spec-
+       tranet installer as a .tap file (or similar).  The  installer  is  also
+       available at the Spectranet site above.
+
+       Once  you  have  a copy of the installer, start Fuse and tick the Spec-
+       tranet option from the Options, Peripherals,  General...   dialog,  and
+       the  state  of  its  write protect jumper controlled via the Spectranet
+       disable option. Once that's done, open  the  installer  file  (use  the
+       Media,  Tape,  Open...   command  rather than File, Open...  to prevent
+       autoloading) and enter the following commands from BASIC:
+
+       CLEAR 26999
+       LOAD "" CODE
+       RANDOMIZE USR 27000
+
+       The screen should turn blue and you'll see around 20 lines  of  message
+       appearing  as  the firmware is installed, starting with "Erasing sector
+       0" and finishing with "Restoring page B", and you'll get  the  familiar
+       0 OK, 0: 1 at the bottom of the screen.
+
+       Now untick the Spectranet disable option from the Options, Peripherals,
+       General...  dialog and reset the Spectrum. You should see a very  brief
+       blue  status  screen,  before the regular copyright screen appears with
+       some Spectranet information at the top -- there should be  four  status
+       lines,  starting  with  "Alioth  Spectranet"  and ending with the Spec-
+       tranet's IP address (which will be 255.255.255.255 at this stage).
+
+       Now trigger an NMI (the Machine / NMI menu option) and you should get a
+       white on blue Spectranet NMI menu with five options.
+
+       Select  [A]  Configure  network  settings  --  this  should lead you to
+       another menu, which will scroll of the top of the screen;  don't  worry
+       about this for now.
+
+       You'll now need to set various options:
+
+       [A] Enable/disable DHCP -- select N
+       [B]  Change  IP  address -- enter the IP address of the machine you are
+       running Fuse on.
+       [C] Change netmask -- enter the appropriate netmask for the IP  address
+       you  selected  above.  If  that  doesn't  mean  anything  to  you,  try
+       255.255.255.0
+       [D] Change default gateway -- enter the  appropriate  gateway  address.
+       If you don't know any better, enter the IP address of your router.
+       [E]  Change primary DNS -- enter the address of your DNS server. If you
+       don't know any better, use Google's public DNS server, 8.8.8.8.
+
+       There is no need to change options [F] or [G], but do select:
+
+       [H] Change hostname -- enter  a  hostname  for  the  Spectranet-enabled
+       machine.  It  doesn't  really matter what you enter here -- it's mostly
+       useful just to replace the junk default name so you can see what you've
+       entered for the other settings.
+
+       Your screen should now look something like this:
+
+       Current configuration
+       ---------------------------------------
+       Use DHCP           : No
+       IP address         : 192.168.000.002
+       Netmask            : 255.255.255.000
+       Default gateway    : 192.168.000.001
+       Primary DNS        : 192.168.000.001
+       Secondary DNS      : 255.255.255.255
+       Hardware address   : FF:FF:FF:FF:FF:FF
+       Hostname           : fuse
+       <menu options>
+
+       If  everything  looks correct, select [I] Save changes and exit (you'll
+       see a brief "Saving configuration..." message) followed by [E] Exit, at
+       which point you'll be returned to BASIC.
+
+       Now type the following commands:
+
+       %cfgnew
+       %cfgcommit
+
+       Which will show the standard 0 OK, 0:1 at the bottom of the screen.
+
+       Reset  the Spectrum again and you'll see the same four line status dis-
+       play, but this time with your IP address on the last line.
+
+       Congratulations! You have now installed  the  Spectranet  firmware.  To
+       save  having  to  go through all that every time you start Fuse, save a
+       .szx snapshot at this point, and load that in every time  you  want  to
+       use the Spectranet.
+
+FILE SELECTION
+       The  way  you  select a file (whether snapshot or tape file) depends on
+       which UI you're using. So firstly, here's how  to  use  the  GTK+  file
+       selector.
+
+       The  selector  shows the directories and files in the current directory
+       in two separate subwindows. If either list is too big  to  fit  in  the
+       window,  you  can  use  the  scrollbar to see the rest (by dragging the
+       slider, for example), or you can use Shift-Tab (to  move  the  keyboard
+       focus  to  a  subwindow) and use the cursor keys.  To change directory,
+       double-click it.
+
+       To choose a file to load you can either double-click it,  or  click  it
+       then click Ok.  Or click Cancel to abort.
+
+       If  you're  using  the  keyboard,  probably  the easiest way to use the
+       selector is to just ignore it and type in the name. This isn't as  irk-
+       some as it sounds, since the filename input box has filename completion
+       -- type part of a directory or file name, then press  Tab.   It  should
+       complete  it. If it was a directory, it moves to that directory; if the
+       completion was ambiguous, it completes as much as possible, and narrows
+       the  filenames  shown to those which match. You should press Enter when
+       you've finished typing the filename, or Esc to abort.
+
+       Now, if you're using the widget UI -- the one using the  Spectrum  font
+       --  the selector works a bit differently. The files and directories are
+       all listed in a single  two-column-wide  window  (the  directories  are
+       shown at the top, ending in `/') -- the names may be truncated onscreen
+       if they're too long to fit.
+
+       To move the cursor, you can either use the cursor keys, or the Spectrum
+       equivalents  5/6/7/8,  or (similarly) h/j/k/l. For faster movement, the
+       Page Up, Page Down, Home, and End keys are supported and do what  you'd
+       expect.  To  select  a file or directory, press Enter.  To abort, press
+       Esc.
+
+       With both selectors, do bear in mind that all files are shown,  whether
+       Fuse would be able to load them or not.
+
+MONITOR/DEBUGGER
+       Firstly,  note  that  the vast majority of this section applies only if
+       you're using the GTK+ user interface; if you're using one of the widget
+       user  interfaces,  you'll get a very basic monitor which shows the cur-
+       rent values of the registers and allows you to single step through exe-
+       cution or continue.
+
+       If  you  are  using the GTK+ user interface, Fuse features a moderately
+       powerful, completely transparent monitor/debugger, which can  be  acti-
+       vated via the Machine, Debugger...  menu option. A debugger window will
+       appear, showing the current state of the emulated machine: the top-left
+       `pane' shows the current state of the Z80 and the last bytes written to
+       any emulated peripherals. The bottom-left pane lists any active  break-
+       points. Moving right, the next pane shows where the Spectrum's 64K mem-
+       ory map (the `W?'  and `C?'  indicate whether each displayed  chunk  is
+       writable or contended respectively).  Fuse tracks the memory mapping of
+       the overall address space in 2KB chunks but will summarise  the  mapped
+       pages  where  they  are  part of the same page of the underlying memory
+       source (e.g. 8KB page sizes in the Spectrum 128K and 4KB pages  in  the
+       Timex clones' DOCK and EXROM banks).
+
+       The  next  pane to the right has a disassembly, which by default starts
+       at the current program counter, although this can be modified either by
+       the `disassemble' command (see below) or by dragging the scrollbar next
+       to it. The next pane shows the current stack, and the  final  pane  any
+       `events'  which  are  due  to  occur and could affect emulation. Any of
+       these panes can be removed by use of the View menu. Below the  displays
+       are  an  entry box for debugger commands, and five buttons for control-
+       ling the debugger:
+
+       Evaluate
+              Evaluate the command currently in the entry box.
+
+       Single Step
+              Run precisely one Z80 opcode and then stop emulation again.
+
+       Continue
+              Restart emulation, but leave the debugger window open. Note that
+              the  debugger window will not be updated while emulation is run-
+              ning.
+
+       Break
+              Stop emulation and return to the debugger.
+
+       Close
+              Close the debugger window and restart emulation.
+
+       Double-clicking on an entry in the stack pane will cause  emulation  to
+       run until the program counter reaches the value stored at that address,
+       while double-clicking on an entry in the `events' pane will cause  emu-
+       lation to run until that time is reached.
+
+       The  main  power  of  the debugger is via the commands entered into the
+       entry box, which are similar in nature (but definitely not identical to
+       or  as  powerful  as)  to those in gdb(1).  In general, the debugger is
+       case-insensitive, and numbers will be interpreted  as  decimal,  unless
+       prefixed  by  either  `0x' or `$' when they will be interpreted as hex.
+       Each command can be abbreviated to the portion not in curly braces.
+
+       ba{se} number
+              Change the debugger window to displaying output in base  number.
+              Available values are 10 (decimal) or 16 (hex).
+
+       br{eakpoint} [address] [if condition]
+              Set  a  breakpoint  to stop emulation and return to the debugger
+              whenever an opcode is executed at address and  condition  evalu-
+              ates  true.  If  address  is omitted, it defaults to the current
+              value of PC.
+
+       br{eakpoint} p{ort} (re{ad}|w{rite}) port [if condition]
+              Set a breakpoint to trigger whenever IO port port is  read  from
+              or written to and condition evaluates true.
+
+       br{eakpoint} (re{ad}|w{rite}) [address] [if condition]
+              Set  a breakpoint to trigger whenever memory location address is
+              read from (other than via an opcode fetch)  or  written  to  and
+              condition evaluates true.  Address again defaults to the current
+              value of PC if omitted.
+
+       br{eakpoint} ti{me} time [if condition]
+              Set a breakpoint to occur time tstates after the  start  of  the
+              every  frame,  assuming  condition  evaluates  true  (if  one is
+              given).
+
+       br{eakpoint} ev{ent} area:detail [if condition]
+              Set  a  breakpoint  to  occur  when  the  event   specified   by
+              area:detail  occurs  and condition evaluates to true. The events
+              which can be caught are:
+
+              beta128:page
+              beta128:unpage
+                     The Beta 128 interface is paged into  or  out  of  memory
+                     respectively.
+              didaktik80:page
+              didaktik80:unpage
+                     The  Didaktik 80 interface is paged into or out of memory
+                     respectively.
+              disciple:page
+              disciple:unpage
+                     The DISCiPLE interface is paged into  or  out  of  memory
+                     respectively.
+              divide:page
+              divide:unpage
+                     The  DivIDE  interface  is  paged  into  or out of memory
+                     respectively.
+              divmmc:page
+              divmmc:unpage
+                     The DivIDE interface is  paged  into  or  out  of  memory
+                     respectively.
+              if1:page
+              if1:unpage
+                     The  Interface 1  shadow ROM is paged into or out of mem-
+                     ory.
+              multiface:page
+              multiface:unpage
+                     The Multiface One/128/3 is paged into or  out  of  memory
+                     respectively.
+              opus:page
+              opus:unpage
+                     The Opus Discovery is paged into or out of memory respec-
+                     tively.
+              plusd:page
+              plusd:unpage
+                     The +D interface is paged into or out of  memory  respec-
+                     tively.
+              rzx:end
+                     An RZX recording finishes playing.
+              speccyboot:page
+              speccyboot:unpage
+                     The SpeccyBoot interface is paged into or out of memory.
+              spectranet:page
+              spectranet:unpage
+                     The Spectranet interface is paged into or out of memory.
+              tape:play
+              tape:stop
+                     The emulated tape starts or stops playing.
+              zxatasp:page
+              zxatasp:unpage
+                     The ZXATASP interface is paged into or out of memory.
+              zxcf:page
+              zxcf:unpage
+                     The ZXCF interface is paged into or out of memory.
+
+              In  all cases, the event can be specified as area:* to catch all
+              events from that area.
+
+       cl{ear} [address]
+              Remove all breakpoints at address or the current value of PC  if
+              address is omitted. Port read/write breakpoints are unaffected.
+
+       com{mmands} id <newline>
+       <debugger command> <newline>
+       <debugger command> <newline>
+       ...
+       end
+              Set  things  such  that  the specified debugger commands will be
+              automatically executed when breakpoint id is triggered. There is
+              currently  no  user  interface  for entering multi-line debugger
+              commands, so the only way to specify this command is on the com-
+              mand-line via the --debugger-command option.
+
+       cond{ition} id [condition]
+              Set  breakpoint  id  to  trigger only when condition is true, or
+              unconditionally if condition is omitted.
+
+       co{ntinue}
+              Equivalent to the Continue button.
+
+       del{ete} [id]
+              Remove breakpoint id, or all breakpoints if id is omitted.
+
+       di{sassemble} address
+              Set the centre panel disassembly to begin at address.
+
+       ex{it} [expression]
+              Exit the emulator immediately, using  the  exit  code  resulting
+              from  the  evaluation of expression, or 0 if expression is omit-
+              ted.
+
+       fi{nish}
+              Exit from the current CALL or equivalent. This isn't infallible:
+              it  works  by setting a temporary breakpoint at the current con-
+              tents of the stack pointer, so will not  function  correctly  if
+              the  code returns to some other point or plays with its stack in
+              other ways. Also, setting this breakpoint doesn't disable  other
+              breakpoints,  which  may  trigger before this one. In that case,
+              the temporary breakpoint remains, and the `continue' command can
+              be used to return to it.
+
+       i{gnore} id count
+              Do  not  trigger  the  next count times that breakpoint id would
+              have triggered.
+
+       n{ext}
+              Step to the opcode following the current one. As with the  `fin-
+              ish'  command,  this  works by setting a temporary breakpoint at
+              the next opcode, so is not infallible.
+
+       o{ut} port value
+              Write value to IO port port.
+
+       pr{int} expression
+              Print the value of expression to standard output.
+
+       se{t} address value
+              Poke value into memory at address.
+
+       se{t} $variable value
+              Set the value of the debugger variable variable to value.
+
+       se{t} area:detail value
+              Set the value of the system variable area:detail to value.   The
+              available system variables are listed below.
+
+       s{tep}
+              Equivalent to the Single Step button.
+
+       t{breakpoint} [options]
+              This  is  the  same  as  the `breakpoint' command in its various
+              forms, except that the breakpoint is temporary: it will  trigger
+              once and once only, and then be removed.
+
+       Addresses  can  be  specified  in  one of two forms: either an absolute
+       addresses, specified by an integer in the range 0x0000 to 0xFFFF or  as
+       a  `source:page:offset'  combination, which refers to a location offset
+       bytes into memory bank page, independent of where  that  bank  is  cur-
+       rently  paged  into  memory.  RAM  and ROM pages are indicated, respec-
+       tively, by `RAM' and `ROM' sources (e.g.  offset  0x1234  in  ROM 1  is
+       specified as `ROM:1:0x1234').  Other available sources are: `Betadisk',
+       `Didaktik 80 RAM', `Didaktik 80 ROM', `DISCiPLE RAM',  `DISCiPLE  ROM',
+       `DivIDE  EPROM',  `DivIDE  RAM',  `DivMMC  EPROM', `DivMMC RAM', `If1',
+       `If2', `Multiface RAM', `Multiface ROM', `Opus RAM', `Opus ROM', `PlusD
+       RAM',  `PlusD  ROM',  `SpeccyBoot',  `Spectranet', `Timex Dock', `Timex
+       EXROM', `uSource', `ZXATASP' and `ZXCF'.  Please, note that  spaces  in
+       memory    sources    should    be    escaped,   e.g.,   `break   Didak-
+       tik\ 80\ ROM:0:0x1234'.  The 48K machines are treated as having a  per-
+       manent  mapping  of  page 5  at  0x4000, page 2 at 0x8000 and page 0 at
+       0xC000; the 16K Spectrum is treated as having page 5 at 0x4000  and  no
+       page at 0x8000 and 0xC000.
+
+       Anywhere  the  debugger  is  expecting a numeric value, except where it
+       expects a breakpoint id, you can  instead  use  a  numeric  expression,
+       which  uses a restricted version of C's syntax; exactly the same syntax
+       is used for conditional breakpoints, with `0' being false and any other
+       value being true. In numeric expressions, you can use integer constants
+       (all calculations are done in  integers),  system  variables,  debugger
+       variables, parentheses, the standard four numeric operations (`+', `-',
+       `*' and `/'), the (non-)equality operators `==' and `!=', the  compari-
+       son  operators `>', `<', `>=' and `<=', bitwise and (`&'), or (`|') and
+       exclusive or (`^') and logical and (`&&') and or (`||').  Square brack-
+       ets  (`['  and  `]')  can  be  used to dereference a value; for example
+       `[0x4000]' will give the value of the first byte of the screen.
+
+       System variables are specified via an `area:detail' syntax. The  avail-
+       able system variables are:
+
+       ay:current
+              The current AY-3-8912 register.
+       divmmc:control
+              The last byte written to DivMMC control port.
+       spectrum:frames
+              The frame count since reset. Note that this variable can only be
+              read, not written to.
+       tape:microphone
+              The current level of the tape input connected to the `EAR' port.
+              Note that this variable can only be read, not written to.
+       ula:last
+              The  last  byte  written to the ULA. Note that this variable can
+              only be read, not written to.
+       ula:mem1ffd
+              The last byte written to memory control  port  used  by  the  ZX
+              Spectrum +2A/3; normally addressed at 0x1ffd, hence the name.
+       ula:mem7ffd
+              The last byte written to primary memory control port used by the
+              ZX Spectrum 128 and later; normally addressed at  0x7ffd,  hence
+              the name.
+       ula:tstates
+              The number of tstates since the last interrupt.
+       z80: register name
+              The  value  of  the specified register. Both 8-bit registers and
+              16-bit register pairs are supported. The MEMPTR / WZ hidden reg-
+              ister  is  also supported. The (presumable) Q hidden register is
+              also supported.
+       z80:im
+              The current interrupt mode of the Z80.
+       z80:iff1
+       z80:iff2
+              1 if the specified interrupt flip-flop is currently set, or 0 if
+              it is not set.
+
+THE POKE FINDER
+       The `poke finder' is a tool which is designed to make the task of find-
+       ing (infinite lives etc.) pokes for games a bit easier: it  is  similar
+       to  the `Lifeguard' utility which was available for use with the Multi-
+       face. It works by maintaining a list of locations in which the  current
+       number  of lives (etc.) may be stored, and having the ability to remove
+       from that list any locations which don't contain a specified value.
+
+       The poke finder dialog contains an entry box for specifying  the  value
+       to be searched for, a count of the current number of possible locations
+       and, if there are less than 20 possible locations, a list of the possi-
+       ble  locations  (in `page:offset' format). The five buttons act as fol-
+       lows:
+
+       Incremented
+              Remove from the list of possible locations all  addresses  which
+              have not been incremented since the last search.
+
+       Decremented
+              Remove  from  the list of possible locations all addresses which
+              have not been decremented since the last search.
+
+       Search
+              Remove from the list of possible locations all  addresses  which
+              do not contain the value specified in the `Search for' field.
+
+       Reset
+              Reset  the poke finder so that all locations are considered pos-
+              sible.
+
+       Close
+              Close the dialog. Note that this  does  not  reset  the  current
+              state of the poke finder.
+
+       Double-clicking  on  an  entry  in  the list of possible locations will
+       cause a breakpoint to be set to trigger whenever that location is writ-
+       ten to.
+
+       An  example of how to use this may make things a bit clearer. We'll use
+       the 128K version of Gryzor. Load the game,  define  keys  to  suit  and
+       start  playing. Immediately pause the game and bring up the poke finder
+       dialog. We note that we currently have 6 lives, so enter `6'  into  the
+       `Search  for' field and click `Search'. This reduces the number of pos-
+       sible locations to around 931 (you may get a slightly different  number
+       depending  on  exactly  when you paused the game). Play along a bit and
+       then (deliberately) lose a life. Pause the game again. As we  now  have
+       5 lives, replace the `6' in the `Search for' field with a `5' and click
+       `Search' again. This then reduces the list  of  possible  locations  to
+       just  one:  page 2,  offset 0x00BC. This is the only location in memory
+       which stored `6' when we had 6 lives and `5' when we  had  5 lives,  so
+       its pretty likely that this is where the lives count is stored. Double-
+       clicking on the `2:0x00BC' entry in the dialog will set the appropriate
+       breakpoint  (you may wish to open the debugger at this point to confirm
+       this). Play along a bit more. When you next lose a life,  emulation  is
+       stopped  with  PC at 0x91CD. Scrolling up a few addresses in the debug-
+       ger's disassembly pane shows a value was loaded from 0x80BC (our  hypo-
+       thetical  lives  counter), decremented and then stored again to 0x80BC,
+       which looks very much like the code to reduce the number of  lives.  We
+       can  now  use  the  debugger  to replace the decrement with a NOP (`set
+       0x91c9 0'), and playing the game some more after this reveals that this
+       has worked and we now have infinite lives.
+
+THE POKE MEMORY
+       Fuse  supports  multiface  POKEs,  allowing  to  modify specific memory
+       addresses in order to cheat (infinite lives, infinite ammo, etc.).
+
+       The `poke memory' dialog contains a list of recently loaded  POKEs  and
+       some entry boxes for adding custom POKEs:
+
+       Bank
+              Sets  the  128K  memory  bank (values `0' to `7') or the current
+              memory mapping (value `8' or blank).
+
+       Address
+              Memory address to modify. Values in range 16384 to 65535 for 48K
+              memory  mode  or  0 to 65535 for 128K memory banks. GTK+ UI also
+              accepts hex addresses.
+
+       Value
+              New value for the former address, in range 0 to 255.  Value  256
+              means "Prompt to the user later".
+
+       It  is  possible  to  load  POKEs from an external file using the File,
+       Open...  menu option or the drag-and-drop functionality in the GTK+ and
+       Win32 UIs.  After loading a snapshot or tape, Fuse will try to automat-
+       ically locate a POK file with the same file name. This means that if we
+       open   `GAME.TAP',   then   Fuse   will  try  to  open  `GAME.POK'  and
+       `POKES/GAME.POK'. See http://www.worldofspectrum.org/POKformat.txt  for
+       more details about this file format.
+
+       POKEs  loaded  in  the list can be activated or deactivated as the user
+       wants and will remain in memory until a machine reset.
+
+THE .DSK FORMAT
+       In general, disk images for the +3 Spectrum are thought of as being  in
+       DSK  format.  However,  this  is  actually a slight oversimplification;
+       there are in fact two similar, but not  identical,  DSK  formats.  (The
+       difference  can  be  seen  by  doing `head -1 dskfile': one format will
+       start `MV - CPCEMU' and the other will start `EXTENDED').
+
+       Fuse supports both the `CPCEMU' and `EXTENDED' formats.
+
+BETA 128 EMULATION
+       Fuse supports Betadisk emulation in its Pentagon  and  Scorpion  emula-
+       tion,  and  also under 48K, TC2048, 128K and +2 (but not +2A) emulation
+       if the Beta 128 interface option from the Options, Peripherals, Disk...
+       dialog  is enabled. When that option is used in 48K or TC2048 emulation
+       the Beta 128 auto-boot in 48K  machines  option  additionally  controls
+       whether the machine boots directly into the TR-DOS system. See the DISK
+       FILE FORMATS section for more details on supported disk file formats.
+
+OPUS DISCOVERY EMULATION
+       By default,  Fuse  emulates  the  Opus  Discovery  interface  with  the
+       optional  2k  RAM  expansion  and  a  second 40 track single sided disk
+       drive.  See the DISK FILE FORMATS section for more details on supported
+       disk  file  formats. The Opus Discovery's printer port is also emulated
+       for output only. (See the PRINTER EMULATION section for more  details.)
+       The  Opus Discovery may only be used with 16K, 48K, 128K, TC2048 and +2
+       (not +2A) emulation.  To access disks, use the same  syntax  as  Inter-
+       face 1 and Microdrives.
+
++D EMULATION
+       Fuse supports emulating the +D disk and printer interface. See the DISK
+       FILE FORMATS section for more details on supported disk  file  formats.
+       The  +D's  printer port is emulated. (See the PRINTER EMULATION section
+       for more details.) The +D may only be used with 48K, 128K and  +2  (not
+       +2A) emulation.  To access disks, you will first need to load G+DOS, by
+       inserting a disk containing the DOS file  (+SYS)  and  entering  "RUN".
+       Once  DOS  is  loaded, you can load to/from +D disks by prefixing file-
+       names with `dn' where `n' is the number of the drive in use.  For exam-
+       ple, `LOAD d1"myfile"' would load the file named `myfile' from the emu-
+       lated drive 1.  Microdrive syntax may also be used.
+
+       To save a snapshot, choose the Machine, NMI menu option, and then press
+       `4'  to save a 48K snapshot, or `5' to save a 128K snapshot.  When sav-
+       ing a 128K snapshot, you must then press Y or N to indicate whether the
+       screen  changed  while  saving the snapshot, to finish saving.  You can
+       also choose `3' to save a  screenshot  to  disk.   Holding  Caps  Shift
+       together  with  any  of  these options will cause the +D to save to the
+       `other' drive to the one used last.
+
+       Options `1' and `2' allow screenshots to be printed (in monochrome,  in
+       normal and large formats respectively) if printer emulation is enabled.
+       For saving and loading of snapshots, and saving of screenshots to disk,
+       G+DOS  must  be  loaded  first, but printing of screenshots can be per-
+       formed without loading G+DOS.
+
+       Finally, `X' will return from the NMI menu.
+
+DIDAKTIK 80 EMULATION
+       Fuse supports Didaktik 80 (and Didaktik 40) emulation.  It emulates the
+       original  version  of the Didaktik 80, running MDOS 1 and with a WD2797
+       floppy controller.  See the DISK FILE FORMATS section for more  details
+       on  supported disk file formats.  The Didaktik 80 may only be used with
+       16K, 48K and TC2048 emulation.  To press the Didaktik 80's `SNAP'  but-
+       ton, choose the Machine, Didaktik SNAP menu option.
+
+DISCIPLE EMULATION
+       Fuse  supports  emulating  the  DISCiPLE  disk  and  printer interface,
+       although it does not currently support emulation of the  Sinclair  Net-
+       work,  or  support  emulation of a DISCiPLE attached to a 128K machine.
+       See the DISK FILE FORMATS section for more details  on  supported  disk
+       file  formats,  which  are  the  same  as for +D emulation as described
+       above. The DISCiPLE's printer port is emulated. (See the PRINTER EMULA-
+       TION  section for more details.) The DISCiPLE may only be used with 48K
+       emulation at present.  To access disks, you will  first  need  to  load
+       GDOS,  by  inserting  a disk containing the DOS file (SYS) and entering
+       "RUN".  Once DOS is loaded, you can load to/from DISCiPLE disks by pre-
+       fixing filenames with `dn' where `n' is the number of the drive in use.
+       For example, `LOAD d1"myfile"' would load the file named `myfile'  from
+       the emulated drive 1.  Microdrive syntax may also be used.
+
+       Snapshots  can  be  saved  in  a  similar  manner  to that of the +D as
+       described above, but note that GDOS on  the  DISCiPLE  contains  a  bug
+       which causes corruption as soon as the NMI button is pressed, affecting
+       saving of snapshots, and also loading of snapshots that were originally
+       saved  with  a  +D or SAM Coup.  This will cause corruption even when a
+       screenshot is printed, or if the menu is  never  even  entered  in  the
+       first  place  (due to Caps Shift not being pressed down, as is required
+       for the DISCiPLE), provided that GDOS  is  loaded.   This  bug  is  not
+       present in G+DOS on the +D.  (Note: this was caused by saving/restoring
+       the AF register twice in the NMI handler, where both  AF  and  the  AF'
+       shadow register should have been saved/restored.)
+
+       The  NMI  button works slightly differently on the DISCiPLE than on the
+       +D.  Caps Shift must be held down whilst pressing the NMI  button,  and
+       there is no `X' option to exit the menu.  Also, printing of screenshots
+       requires GDOS to be loaded.  Depending on the  UI  that  you're  using,
+       holding  down  Caps  Shift whilst choosing the Machine, NMI menu option
+       may be slightly tricky, or even impossible.  For the  GTK+  UI,  ensure
+       that  the  Shift  key is held before entering on the Machine menu.  For
+       the widget UI, it does not seem possible to perform this action.
+
+DISK FILE FORMATS
+       Fuse supports several disk image formats in its +D, Didaktik,  DISCiPLE
+       and Beta 128 emulation.
+
+       For reading:
+
+       .UDI
+              Ultra    Disk    Image;    for    specification    please    see
+              http://faqwiki.zxnet.co.uk/wiki/UDI_format                    or
+              http://zxmak.chat.ru/docs.htm
+
+              This  is  the only image format which can store all the relevant
+              information of the recorded data on a magnetic disk, so  it  can
+              be  used  for  any  non  standard disk format. Fuse can read all
+              extended track types too (mixed FM/MFM, or  tracks  with  `WEAK'
+              data or even compressed tracks too).
+
+       .FDI
+              UKV Spectrum Debugger disk image format.
+
+       .MGT .IMG
+              DISCiPLE/+D file formats.
+
+       .SAD
+              For compatibility with SAM Coup disk images using these formats.
+              Note that SAM Coup  `.DSK'  images  share  the  same  format  as
+              `.MGT'.
+
+       .D80 .D40
+              Didaktik 80 and Didaktik 40 file formats.
+
+       .TRD
+              TR-DOS  disk  image. TRD and SCL sectors are loaded interleaved,
+              therefore you might experience problems with  TR-DOS  ROMs  that
+              use the turbo format (sequential sectors); for detailed informa-
+              tion            please            see             http://web.ar-
+              chive.org/web/20070808150548/http://www.ram-
+              soft.bbk.org/tech/tr-info.zip
+
+       .SCL
+              A simple archive format for TR-DOS disk files. For specification
+              please see http://www.zx-modules.de/fileformats/sclformat.html
+
+       .TD0
+              Teledisk image format; Fuse supports only files which do not use
+              the "Advanced Compression" option. Detailed description found in
+              http://www.classiccmp.org/dunfield/img54306/td0notes.txt     and
+              https://web.ar-
+              chive.org/web/20130116072335/http://www.fpns.net/willy/wteledsk.htm
+
+       .DSK
+              CPC disk image format; Fuse supports the plain old and  the  new
+              extended  CPC format too. Further information please see the THE
+              .DSK  FORMAT  section  and  the  CPCEMU  manual  section   7.7.1
+              http://www.cpc-emu.org/linux/cpcemu_e.txt         or         the
+              http://www.cpctech.org.uk/docs/extdsk.html
+
+       .OPD .OPU
+              Opus Discovery file formats.
+
+       Fuse supports most of the above formats for  writing:  .UDI  .FDI  .MGT
+       .IMG .SAD .D80 .D40 .TRD .SCL .OPD .OPU .DSK (only the old CPC format).
+
+       You can save disk images with any output format, just select the appro-
+       priate extension. (e.g.  `elite3.udi' to save as an UDI file).  If  the
+       appropriate  libraries were available when libspectrum(3) was compiled,
+       than Fuse will try to create UDI images with compressed tracks to  save
+       disk space.  There is a .LOG `image' format for debugging purpose. This
+       is a plain text file that contains three dumps of the loaded disk image
+       at different details.  Not all image formats can store all disk images.
+       You cannot save a disk image with an inappropriate  format  that  loses
+       some information (e.g. variable track length or sector length).
+
+WEAK DISK DATA
+       Some  copy  protections  have  what is described as `weak/random' data.
+       Each time the sector is read one or more bytes will change,  the  value
+       may  be  random between consecutive reads of the same sector.  Two disk
+       image formats (Extended DSK and UDI) can store this type of data.  Fuse
+       can read and use weak sector data from EDSK and UDI files when present,
+       and can save back weak sector data to UDI image format.
+
+MOVIE RECORDING
+       Fuse can save movies with sound in a specific file format (FMF).   This
+       recording  is  very  fast, and has a moderate size, but you need to use
+       the fmfconv(1) program in fuse-utils(1) to convert into  regular  video
+       and/or  audio  files.   The  --movie-compr option allows you to set the
+       compression level to None, Lossless or High. If zlib(3) is  not  avail-
+       able,  only  None is valid. The default when Zlib is available is Loss-
+       less.  Recording a movie may slow down  emulation,  if  you  experience
+       performance problems, you can try to set compression to None.
+
+       Fuse records every displayed frame, so by default the recorded file has
+       about 50 video frame per second. A standard  video  has  about  24-30/s
+       framerate,  so if you set Options/General/Frame rate 1:n or the equiva-
+       lent --rate command line option to 2 than recording frame rate  reduces
+       about  25/s.  The  exact  frame rate depends on the Z80 clock frequency
+       which varies depending on the specific emulated machine.
+
+       Note: You can see all of the "gfx" effects only if the Fuse frame  rate
+       option is set to 1, but in most cases you can safely use 2. Also, movie
+       recording stops if the emulated machine is changed.
+
+       The recorded sound sampling rate and the channel number is  equal  with
+       the  Fuse generated sound sampling rate (44100 Hz by default) and chan-
+       nel number (mono by default). The common sampling frequencies in  stan-
+       dard  video  files  are  44100 Hz and 48000 Hz. If you use --sound-freq
+       command line option you can change the frequency.
+
+       You can record stereo sound if you use  AY  stereo  separation  or  the
+       equivalent --separation command line switch.
+
+       You  can  use fmfconv(1) to convert recorded movie file into a standard
+       video file.
+
+       Examples
+
+       fuse --movie-start output.fmf --rate 2 --sound-freq 44100  --separation
+       ACB
+
+       start video recording about 25/s video frame rate and 44100 Hz sampling
+       frequency stereo sound default compression level.
+
+COMPRESSED FILES
+       Assuming the appropriate libraries were available  when  libspectrum(3)
+       was compiled, snapshots, tape images, dock cartridges and input record-
+       ing files (RZX) can  be  read  from  files  compressed  with  bzip2(3),
+       gzip(3)  or  zip(3) just as if they were uncompressed. In the zip case,
+       only the first supported file  found  inside  the  archive  is  loaded.
+       There is currently no support for reading compressed +3, DISCiPLE/+D or
+       Beta disk images.
+
+BUGS
+       Selecting a startup filter doesn't work properly with  user  interfaces
+       other than SDL, Win32 and GTK+.
+
+       Changing  virtual  consoles  when  using  SVGAlib  for joystick support
+       causes Fuse to exit. If this  is  a  problem,  compile  Fuse  with  the
+       `--disable-ui-joystick' option.
+
+       The poke finder can't search outside `normal' RAM.
+
+       The  libao  file output devices not work properly with the GTK+ UI.  No
+       error reporting, but the created file does not contain any sound  data.
+       If  you  use a `weak' machine alsa09 makes a lot of clicks and pops and
+       will output `ALSA: underrun, at least 0ms.'  error messages.
+
+FILES
+       ~/.fuserc
+
+SEE ALSO
+       bzip2(3),   fmfconv(1),   fuse-utils(1),    gzip(3),    libspectrum(3),
+       ogg123(1), xspect(1), xzx(1), zip(3).
+
+       The comp.sys.sinclair Spectrum FAQ, at
+       http://www.worldofspectrum.org/faq/index.html.
+
+AUTHOR
+       Philip Kendall (philip-fuse@shadowmagic.org.uk).
+
+       Matan  Ziv-Av  wrote the SVGAlib and framebuffer UIs, the glib replace-
+       ment code, and did some work on the OSS-specific  sound  code  and  the
+       original widget UI code.
+
+       Russell  Marks  wrote  the sound emulation and OSS-specific sound code,
+       the joystick emulation, some of the printer code, and the original ver-
+       sion of this man page.
+
+       John  Elliott's  lib765 and libdsk libraries were used for the original
+       +3 disk and disk image support.
+
+       Ian Collier wrote the ZX Printer emulation (for xz80).
+
+       Darren Salt wrote the original versions of the code for  +3  emulation,
+       SLT support, MITSHM support (for the Xlib UI), TZX raw data blocks, RZX
+       embedded snapshots and compression, the Kempston  mouse  emulation  and
+       made many improvements to the widget code.
+
+       Alexander Yurchenko wrote the OpenBSD/Solaris-specific sound code.
+
+       Fredrick  Meunier  wrote  the  TC2048, TS2068, Pentagon and Spectrum SE
+       support, the CoreAudio sound code, as well as maintaining the OS X port
+       and importing the graphics filter code.
+
+       Ludvig  Strigeus  and  The  ScummVM project wrote the original graphics
+       filter code.
+
+       Dmitry Sanarin wrote the original Beta disk  interface  emulation  (for
+       Glukalka).
+
+       Witold Filipczyk wrote the TC2068 support.
+
+       Matthew Westcott wrote the AY logging code and the DivIDE emulation.
+
+       Marek  Januszewski  wrote  various bits of code to make Fuse work under
+       Win32, including the DirectDraw user interface.
+
+       Sergio Baldov made many improvements to the Win32 UI.
+
+       Stuart Brady wrote the DISCiPLE and +D  emulation,  Scorpion  emulation
+       and the HP-UX sound code.
+
+       Garry  Lancaster wrote the 8-bit IDE, ZXATASP and ZXCF interface emula-
+       tions.
+
+       Gergely Szasz wrote the Interface 1, Microdrive  emulation  and  Didak-
+       tik 80  emulation, the PAL TV scalers, the TV 3x scaler, the movie log-
+       ging code, the ALSA and libao sound code,  the  PD765  disk  controller
+       used in the +3 and made many improvements to the widget code.
+
+       Michael  D  Wynne wrote the original Opus disk interface emulation (for
+       EightyOne).
+
+       Patrik Persson wrote the SpeccyBoot emulation.
+
+
+
+Version 1.5.7                 9th December, 2018                       fuse(1)
\ No newline at end of file
diff --git a/Platform/roms/read.me b/Platform/roms/read.me
new file mode 100644
index 0000000..3bef3e8
--- /dev/null
+++ b/Platform/roms/read.me
@@ -0,0 +1 @@
+Put any extra roms here to include in the build
diff --git a/configure.ac b/configure.ac
index 2db9913..b4c5d08 100644
--- a/configure.ac
+++ b/configure.ac
@@ -300,6 +300,54 @@
   fi
 fi
 
+dnl Look for GCW ZERO (default=no)
+gcw0=no
+if test -z "$UI"; then
+  AC_MSG_CHECKING(whether GCW ZERO requested)
+  AC_ARG_WITH(gcw0,
+  [  --with-gcw0             Build for GCW ZERO (--with-sdl)],
+  if test "$withval" = no; then gcw0=no; else gcw0=yes; fi,
+  gcw0=no)
+  AC_MSG_RESULT($gcw0)
+  if test "$gcw0" = yes; then
+    if test "$sdl_available" = yes; then
+      AC_DEFINE([GCWZERO], 1, [Defined if GCW ZERO is in use])
+      AC_DEFINE([VKEYBOARD], 1, [Virtual Keyboard defined if GCW ZERO is in use])
+      AC_DEFINE([UI_SDL], 1, [Defined if the SDL UI in use])
+      AC_DEFINE([USE_WIDGET], 1, [Defined if we're using a widget-based UI])
+      UI=sdl
+      WIDGET=widget
+      use_sdl=yes
+    else
+      AC_MSG_ERROR([SDL version $SDL_VERSION not found])
+    fi
+  fi
+fi
+
+dnl Look for RetroFW 2 (default=no)
+retrofw=no
+if test -z "$UI"; then
+  AC_MSG_CHECKING(whether RetroFW 2 requested)
+  AC_ARG_WITH(retrofw,
+  [  --with-retrofw          Build for RetroFW 2 (--with-sdl)],
+  if test "$withval" = no; then retrofw=no; else retrofw=yes; fi,
+  retrofw=no)
+  AC_MSG_RESULT($retrofw)
+  if test "$retrofw" = yes; then
+    if test "$sdl_available" = yes; then
+      AC_DEFINE([GCWZERO], 1, [Defined if RetroFW 2 is in use])
+      AC_DEFINE([VKEYBOARD], 1, [Virtual Keyboard defined if RetroFW 2 is in use])
+      AC_DEFINE([UI_SDL], 1, [Defined if the SDL UI in use])
+      AC_DEFINE([USE_WIDGET], 1, [Defined if we're using a widget-based UI])
+      UI=sdl
+      WIDGET=widget
+      use_sdl=yes
+    else
+      AC_MSG_ERROR([SDL version $SDL_VERSION not found])
+    fi
+  fi
+fi
+
 dnl Look for null UI (default=no)
 if test -z "$UI"; then
   AC_MSG_CHECKING(whether null UI requested)
@@ -505,6 +553,15 @@
 libpng=yes)
 AC_MSG_RESULT($libpng)
 if test "$libpng" = yes; then
+  if test "$gcw0" = yes; then
+  PKG_CHECK_MODULES(
+    [PNG],
+    [libpng14],
+    [AC_DEFINE([USE_LIBPNG], 1, [Defined if we're going to be using the installed libpng])],
+    [AC_MSG_WARN([libpng not found - saving screenshots disabled])
+     libpng=no]
+  )
+  else
   PKG_CHECK_MODULES(
     [PNG],
     [libpng],
@@ -512,6 +569,7 @@
     [AC_MSG_WARN([libpng not found - saving screenshots disabled])
      libpng=no]
   )
+  fi
 fi
 
 AC_SUBST(PNG_CFLAGS)
@@ -1046,6 +1104,8 @@
 echo "Spectranet support: ${build_spectranet}"
 echo "SpeccyBoot support: ${linux_tap:-no}"
 echo "Desktop integration: ${desktopintegration}"
+echo "GCW ZERO: ${gcw0}"
+echo "RetroFW 2: ${retrofw}"
 echo ""
 echo "Type 'make' to compile Fuse"
 echo ""
diff --git a/display.c b/display.c
index 12d01bd..6ff68d0 100644
--- a/display.c
+++ b/display.c
@@ -1027,6 +1027,55 @@
           * sizeof(libspectrum_dword) );
 }
 
+#if VKEYBOARD
+void display_refresh_main_screen_rect( int x, int y, int w, int h )
+{
+  size_t i;
+  libspectrum_dword dirty;
+  int column = machine_current->timex ? x < DISPLAY_BORDER_WIDTH ? 0 : ( x - DISPLAY_BORDER_WIDTH ) >> 4
+                                      : x < DISPLAY_BORDER_ASPECT_WIDTH ? 0 : ( x - DISPLAY_BORDER_ASPECT_WIDTH ) >> 3;
+  int row    = machine_current->timex ? y < DISPLAY_BORDER_HEIGHT << 1 ?  0 : ( y - ( DISPLAY_BORDER_HEIGHT << 1 ) ) >> 1
+                                      : y < DISPLAY_BORDER_HEIGHT ?  0 : y - DISPLAY_BORDER_HEIGHT;
+  int bytes  = machine_current->timex ? x < DISPLAY_BORDER_WIDTH ? ( x + w - DISPLAY_BORDER_WIDTH ) >> 4 : w >> 4
+                                      : x < DISPLAY_BORDER_ASPECT_WIDTH ? ( x + w - DISPLAY_BORDER_ASPECT_WIDTH ) >> 3 : w >> 3;
+  int end    = column + bytes > DISPLAY_WIDTH_COLS ? DISPLAY_WIDTH_COLS : column + bytes;
+  int height = machine_current->timex ? y < DISPLAY_BORDER_HEIGHT << 1 ? ( y + h - ( DISPLAY_BORDER_HEIGHT << 1 ) ) >> 1 : h >> 1
+                                      : y < DISPLAY_BORDER_HEIGHT ? y + h - DISPLAY_BORDER_HEIGHT : h;
+
+  dirty = display_all_dirty;
+  dirty >>= column;
+  dirty <<= column + ( DISPLAY_WIDTH_COLS - end );
+  dirty >>= ( DISPLAY_WIDTH_COLS - end );
+  for( i = row; i < row + height && i < DISPLAY_HEIGHT; i++ )
+    display_maybe_dirty[i] |= dirty;
+}
+
+void display_refresh_rect( int x, int y, int w, int h )
+{
+  size_t i, j;
+  int index;
+  int column = machine_current->timex ? x >> 4 : x >> 3;
+  int bytes  = machine_current->timex ? w >> 4 : w >> 3 ;
+  int row    = machine_current->timex ? ( y >> 1 ) : y;
+  int height = machine_current->timex ? h >> 1 : h;
+  libspectrum_dword dirty;
+
+  display_refresh_main_screen_rect(x,y,w,h);
+
+  dirty = display_all_dirty;
+  dirty >>= column;
+  dirty <<= column + ( DISPLAY_SCREEN_WIDTH_COLS - ( column + bytes ) );
+  dirty >>= ( DISPLAY_SCREEN_WIDTH_COLS - ( column + bytes ) );
+  for( i = row; i < row + height && i < DISPLAY_SCREEN_HEIGHT; i++ ) {
+    display_is_dirty[i] |= dirty;
+    for ( j = column; j < column + bytes; j++) {
+      index = j + i * DISPLAY_SCREEN_WIDTH_COLS;
+      display_last_screen[index] = 0xff;
+    }
+  }
+}
+#endif
+
 /* Fetch pixel (x, y). On a Timex this will be a point on a 640x480 canvas,
    on a Sinclair/Amstrad/Russian clone this will be a point on a 320x240
    canvas */
diff --git a/display.h b/display.h
index f7e4dbe..cc7d55e 100644
--- a/display.h
+++ b/display.h
@@ -115,6 +115,10 @@
 int display_frame(void);
 void display_refresh_main_screen(void);
 void display_refresh_all(void);
+#if VKEYBOARD
+void display_refresh_main_screen_rect( int x, int y, int w, int h );
+void display_refresh_rect( int x, int y, int w, int h );
+#endif
 
 #define display_get_offset( x, y ) display_line_start[(y)]+(x)
 
diff --git a/fuse.c b/fuse.c
index 0a41fa0..205b050 100644
--- a/fuse.c
+++ b/fuse.c
@@ -37,6 +37,14 @@
 
 #include <unistd.h>
 
+#ifdef GCWZERO
+#ifdef HAVE_LIBGEN_H
+#include <libgen.h>
+#endif
+#include <limits.h>
+#include "compat.h"
+#endif
+
 /* We need to include SDL.h on Mac O X and Windows to do some magic
    bootstrapping by redefining main. As we now allow SDL joystick code to be
    used in the GTK+ and Xlib UIs we need to also do the magic when that code is
@@ -375,6 +383,10 @@
 
   if( settings_init( &first_arg, argc, argv ) ) return 1;
 
+#ifdef GCWZERO
+  settings_current.full_screen = 1;
+#endif
+
   if( settings_current.show_version ) {
     fuse_show_version();
     return 0;
@@ -759,6 +771,20 @@
     }
 
     utils_close_file( &file );
+
+#ifdef GCWZERO
+    if (class != LIBSPECTRUM_CLASS_UNKNOWN) {
+      char *path = 0;
+      char buffer[PATH_MAX];
+      last_filename = utils_last_filename( filename );
+      strncpy( buffer, filename, PATH_MAX );
+      path = dirname(buffer);
+      if (path && path[0] != '\0') {
+        snprintf(buffer, PATH_MAX, "%s", path);
+        chdir(buffer);
+      }
+    }
+#endif
   }
 
   return 0;
diff --git a/input.c b/input.c
index e8c4528..3075de3 100644
--- a/input.c
+++ b/input.c
@@ -37,11 +37,211 @@
 static int keyrelease( const input_event_key_t *event );
 static int do_joystick( const input_event_joystick_t *joystick_event,
 			int press );
+#ifdef GCWZERO
+static int input_event_gcw0( const input_event_t *event );
+
+int
+input_event_gcw0( const input_event_t *event ) {
+  if (ui_widget_level == -1 && !vkeyboard_enabled ) {
+    input_event_t nevent;
+    if (settings_current.joystick_1_output) {
+      nevent.types.joystick.button = 0;
+      switch (event->types.key.native_key) {
+      case INPUT_KEY_Up:
+        nevent.types.joystick.button = INPUT_JOYSTICK_UP;
+        break;
+
+      case INPUT_KEY_Down:
+        nevent.types.joystick.button = INPUT_JOYSTICK_DOWN;
+        break;
+
+      case INPUT_KEY_Left:
+        nevent.types.joystick.button = INPUT_JOYSTICK_LEFT;
+        break;
+
+      case INPUT_KEY_Right:
+        nevent.types.joystick.button = INPUT_JOYSTICK_RIGHT;
+        break;
+
+      case INPUT_KEY_Control_L:
+        if (settings_current.joystick_1_fire_1)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_1;
+        break; /* A */
+
+      case INPUT_KEY_Alt_L:
+        if (settings_current.joystick_1_fire_2)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_2;
+        break; /* B */
+
+      case INPUT_KEY_space:
+        if (settings_current.joystick_1_fire_3)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_3;
+        break; /* X */
+
+      case INPUT_KEY_Shift_L:
+        if (settings_current.joystick_1_fire_4)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_4;
+        break; /* Y */
+
+      case INPUT_KEY_Tab:
+        if (settings_current.joystick_1_fire_5)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_5;
+        break; /* L1 */
+
+      case INPUT_KEY_BackSpace:
+        if (settings_current.joystick_1_fire_6)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_6;
+        break; /* R1 */
+
+      case INPUT_KEY_Page_Up:
+        if (settings_current.joystick_1_fire_7)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_7;
+        break; /* L2 */
+
+      case INPUT_KEY_Page_Down:
+        if (settings_current.joystick_1_fire_8)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_8;
+        break; /* R2 */
+
+      case INPUT_KEY_Return:
+        if (settings_current.joystick_1_fire_9)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_9;
+        break; /* Start */
+
+      case INPUT_KEY_Escape:
+        if (settings_current.joystick_1_fire_10)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_10;
+        break; /* Select */
+
+      case INPUT_KEY_slash: /* Translated unicode key */
+        if (settings_current.joystick_1_fire_11)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_11;
+        break; /* L3 */
+
+      case INPUT_KEY_period: /* Translated unicode key */
+        if (settings_current.joystick_1_fire_12)
+          nevent.types.joystick.button = INPUT_JOYSTICK_FIRE_12;
+        break; /* R3 */
+
+      default:
+        break;
+      }
+      if (nevent.types.joystick.button) {
+        nevent.types.joystick.which = 0; /*Joystick 0*/
+        switch (event->type) {
+
+        case INPUT_EVENT_KEYPRESS:
+          nevent.type = INPUT_EVENT_JOYSTICK_PRESS;
+          return do_joystick(&(nevent.types.joystick), 1);
+
+        case INPUT_EVENT_KEYRELEASE:
+          nevent.type = INPUT_EVENT_JOYSTICK_RELEASE;
+          return do_joystick(&(nevent.types.joystick), 0);
+
+        default: break;
+        }
+      }
+    } else if (settings_current.joystick_gcw0_output) {
+      keyboard_key_name key = 0;
+      nevent.types.key.spectrum_key = 0;
+      switch (event->types.key.native_key) {
+      case INPUT_KEY_Up:
+        key = settings_current.joystick_gcw0_up;
+        break;
+
+      case INPUT_KEY_Down:
+        key = settings_current.joystick_gcw0_down;
+        break;
+
+      case INPUT_KEY_Left:
+        key = settings_current.joystick_gcw0_left;
+        break;
+
+      case INPUT_KEY_Right:
+        key = settings_current.joystick_gcw0_right;
+        break;
+
+      case INPUT_KEY_Control_L:
+        key = settings_current.joystick_gcw0_a;
+        break; /* A */
+
+      case INPUT_KEY_Alt_L:
+        key = settings_current.joystick_gcw0_b;
+        break; /* B */
+
+      case INPUT_KEY_space:
+        key = settings_current.joystick_gcw0_x;
+        break; /* X */
+
+      case INPUT_KEY_Shift_L:
+        key = settings_current.joystick_gcw0_y;
+        break; /* Y */
+
+      case INPUT_KEY_Tab:
+        key = settings_current.joystick_gcw0_l1;
+        break; /* L1 */
+
+      case INPUT_KEY_BackSpace:
+        key = settings_current.joystick_gcw0_r1;
+        break; /* R1 */
+
+      case INPUT_KEY_Page_Up:
+        key = settings_current.joystick_gcw0_l2;
+        break; /* L2 */
+
+      case INPUT_KEY_Page_Down:
+        key = settings_current.joystick_gcw0_r2;
+        break; /* R2 */
+
+      case INPUT_KEY_Return:
+        key = settings_current.joystick_gcw0_start;
+        break; /* Start */
+
+      case INPUT_KEY_Escape:
+        key = settings_current.joystick_gcw0_select;
+        break; /* Select */
+
+      case INPUT_KEY_slash: /* Translated unicode key */
+        key = settings_current.joystick_gcw0_l3;
+        break; /* L3 */
+
+      case INPUT_KEY_period: /* Translated unicode key */
+        key = settings_current.joystick_gcw0_r3;
+        break; /* R3 */
+
+      default:
+        break;
+      }
+      if (key) {
+        switch (event->type) {
+        case INPUT_EVENT_KEYPRESS: keyboard_press(key);
+          return 0;
+        case INPUT_EVENT_KEYRELEASE: keyboard_release(key);
+          return 0;
+        default: break;
+        }
+      }
+    }
+
+    /* Virtual Keyboard toggle with Start key */
+    if ( event->type == INPUT_EVENT_KEYPRESS && event->types.key.native_key == INPUT_KEY_Return ) {
+      vkeyboard_enabled = !vkeyboard_enabled;
+      return 0;
+    }
+  }
+
+  return 1;
+}
+#endif
 
 int
 input_event( const input_event_t *event )
 {
 
+#ifdef GCWZERO
+  if ( !input_event_gcw0(event) ) return 0;
+#endif
+
   switch( event->type ) {
 
   case INPUT_EVENT_KEYPRESS: return keypress( &( event->types.key ) );
@@ -236,10 +436,18 @@
 {
   int swallow;
 
+#if VKEYBOARD
+  if ( vkeyboard_enabled ) {
+    ui_widget_input_vkeyboard( event->native_key, 1 );
+    return 0;
+  }
+#endif
+#ifdef USE_WIDGET
   if( ui_widget_level >= 0 ) {
     ui_widget_keyhandler( event->native_key );
     return 0;
   }
+#endif
 
   /* Escape => ask UI to end mouse grab, return if grab ended */
   if( event->native_key == INPUT_KEY_Escape && ui_mouse_grabbed ) {
@@ -281,6 +489,12 @@
 static int
 keyrelease( const input_event_key_t *event )
 {
+#if VKEYBOARD
+  if ( vkeyboard_enabled ) {
+    ui_widget_input_vkeyboard( event->native_key, 0 );
+    return 0;
+  }
+#endif
   if( !settings_current.recreated_spectrum ) {
     send_keyboard_release( event->spectrum_key );
   }
@@ -364,12 +578,19 @@
 {
   int which;
 
+#if VKEYBOARD
+  if ( vkeyboard_enabled ) {
+    ui_widget_input_vkeyboard( joystick_event->button, press );
+    return 0;
+  }
+#endif
 #ifdef USE_WIDGET
   if( ui_widget_level >= 0 ) {
     if( press ) ui_widget_keyhandler( joystick_event->button );
     return 0;
   }
 
+#ifndef GCWZERO
 #ifndef GEKKO /* Home button opens the menu on Wii */
   switch( joystick_event->button ) {
   case INPUT_JOYSTICK_FIRE_2:
@@ -380,6 +601,7 @@
 
   }
 #endif  /* #ifndef GEKKO */
+#endif  /* #ifndef GCWZERO */
 
 #endif				/* #ifdef USE_WIDGET */
 
diff --git a/input.h b/input.h
index 407c274..92af5e5 100644
--- a/input.h
+++ b/input.h
@@ -147,6 +147,9 @@
 
   INPUT_KEY_KP_Enter = 0x8d,
 
+  INPUT_KEY_KP_Divide,
+  INPUT_KEY_KP_Period,
+
   INPUT_KEY_Up = 0x100,
   INPUT_KEY_Down,
   INPUT_KEY_Left,
diff --git a/keyboard.c b/keyboard.c
index 50926b4..4a5a8cc 100644
--- a/keyboard.c
+++ b/keyboard.c
@@ -133,6 +133,9 @@
 
   { INPUT_KEY_KP_Enter,    { KEYBOARD_Enter, KEYBOARD_NONE   } },
 
+  { INPUT_KEY_KP_Divide,   { KEYBOARD_v,     KEYBOARD_Symbol } },
+  { INPUT_KEY_KP_Period,   { KEYBOARD_m,     KEYBOARD_Symbol } },
+
   { INPUT_KEY_NONE, { KEYBOARD_NONE, KEYBOARD_NONE } } /* End marker */
 
 };
diff --git a/keysyms.dat b/keysyms.dat
index 05f164a..2986e30 100644
--- a/keysyms.dat
+++ b/keysyms.dat
@@ -135,6 +135,9 @@
 
 KP_Enter
 
+KP_Divide
+KP_Period
+
 Up
 Down
 Left
diff --git a/keysyms.pl b/keysyms.pl
index 169ddff..9cfb16d 100755
--- a/keysyms.pl
+++ b/keysyms.pl
@@ -165,7 +165,7 @@
                          Control_L Control_R Alt_L Alt_R Meta_L Meta_R
                          Super_L Super_R Mode_switch Up Down Left Right
                          Insert Delete Home End Page_Up Page_Down KP_Enter
-                         dead_circumflex ) },
+                         dead_circumflex KP_Divide KP_Period ) },
 	      translations => {
 		  apostrophe  => 'QUOTE',
 		  asciicircum => 'CARET',
diff --git a/menu.c b/menu.c
index b2e4dd9..cf394d2 100644
--- a/menu.c
+++ b/menu.c
@@ -25,7 +25,10 @@
 #include <config.h>
 
 #include <libspectrum.h>
-
+#ifdef GCWZERO
+#include <stdlib.h>
+#include <string.h>
+#endif
 #include "event.h"
 #include "fuse.h"
 #include "menu.h"
@@ -317,11 +320,13 @@
   fuse_emulation_unpause();
 }
 
+#ifndef GCWZERO
 MENU_CALLBACK( menu_options_fullscreen )
 {
   ui_widget_finish();
   settings_current.full_screen = !settings_current.full_screen;
 }
+#endif
 
 MENU_CALLBACK( menu_options_save )
 {
@@ -1076,6 +1081,14 @@
   return scaler_name(current_scaler);
 }
 
+#ifdef GCWZERO
+const char*
+menu_gcw0_keyboard_detail( void )
+{
+  return joystick_name_gcw0[ settings_current.joystick_gcw0_output ];
+}
+#endif
+
 const char*
 menu_keyboard_joystick_detail( void )
 {
diff --git a/menu.h b/menu.h
index c250e88..b58c44d 100644
--- a/menu.h
+++ b/menu.h
@@ -76,7 +76,9 @@
 MENU_CALLBACK_WITH_ACTION( menu_options_selectroms_peripheral_select );
 MENU_CALLBACK( menu_options_filter );
 MENU_DETAIL( menu_filter_detail );
+#ifndef GCWZERO
 MENU_CALLBACK( menu_options_fullscreen );
+#endif
 MENU_CALLBACK( menu_options_save );
 
 MENU_CALLBACK( menu_machine_profiler_start );
@@ -158,6 +160,9 @@
 MENU_DETAIL( menu_disciple1_detail );
 MENU_DETAIL( menu_disciple2_detail );
 MENU_CALLBACK_WITH_ACTION( menu_options_joysticks_select );
+#ifdef GCWZERO
+MENU_DETAIL( menu_gcw0_keyboard_detail );
+#endif
 MENU_DETAIL( menu_keyboard_joystick_detail );
 MENU_DETAIL( menu_joystick_1_detail );
 MENU_DETAIL( menu_joystick_2_detail );
@@ -173,6 +178,9 @@
 
 MENU_CALLBACK( menu_help_keyboard );
 MENU_CALLBACK( menu_help_about );
+#if VKEYBOARD
+MENU_CALLBACK( menu_vkeyboard );
+#endif
 
 /* Called from elsewhere (generally from one of the routines defined
    in menu.c) */
diff --git a/menu_data.dat b/menu_data.dat
index 3945c72..120e6c7 100644
--- a/menu_data.dat
+++ b/menu_data.dat
@@ -88,10 +88,17 @@
 
 Options/_Joysticks, Branch
 #ifdef USE_JOYSTICK
+#ifdef GCWZERO
+Options/Joysticks/GCW0 Joystick _1..., Item,, menu_options_joysticks_select, menu_joystick_1_detail, 1
+#else
 Options/Joysticks/Joystick _1..., Item,, menu_options_joysticks_select, menu_joystick_1_detail, 1
 Options/Joysticks/Joystick _2..., Item,, menu_options_joysticks_select, menu_joystick_2_detail, 2
 #endif
+#endif
 Options/Joysticks/_Keyboard..., Item,, menu_options_joysticks_select, menu_keyboard_joystick_detail, 3
+#ifdef GCWZERO
+Options/Joysticks/_GCW0 Keyboard..., Item,, menu_options_joysticks_select, menu_gcw0_keyboard_detail, 4
+#endif
 
 Options/S_elect ROMs, Branch
 
@@ -128,8 +135,10 @@
 Options/_Filter..., Item,,, menu_filter_detail
 
 #ifdef UI_SDL
+#ifndef GCWZERO
 Options/F_ull screen, Item, F11
 #endif
+#endif
 
 Options/_Disk options..., Item
 
diff --git a/peripherals/joystick.c b/peripherals/joystick.c
index d3edc0d..cfaf463 100644
--- a/peripherals/joystick.c
+++ b/peripherals/joystick.c
@@ -77,6 +77,12 @@
   "Fuller"
 };
 
+#ifdef GCWZERO
+const char *joystick_name_gcw0[] = {
+  "None", "Activated"
+};
+#endif
+
 const char *joystick_connection[ JOYSTICK_CONN_COUNT ] = {
   "None",
   "Keyboard",
@@ -167,6 +173,10 @@
   case JOYSTICK_KEYBOARD:
     type = settings_current.joystick_keyboard_output; break;
 
+#ifdef GCWZERO
+  case GCW0_KEYBOARD:
+    type = settings_current.joystick_gcw0_output; break;
+#endif
   default:
     return 0;
   }
diff --git a/peripherals/joystick.h b/peripherals/joystick.h
index dc27d16..36d0ff3 100644
--- a/peripherals/joystick.h
+++ b/peripherals/joystick.h
@@ -35,7 +35,10 @@
 
 /* A constant to identify the joystick emulated via the keyboard */
 #define JOYSTICK_KEYBOARD 2
-
+#ifdef GCWZERO
+/* A constant to identify the keyboard emulated via the GCW0 Buttons */
+#define GCW0_KEYBOARD 3
+#endif
 typedef enum joystick_type_t {
 
   JOYSTICK_TYPE_NONE = 0,
@@ -53,6 +56,9 @@
 #define JOYSTICK_TYPE_COUNT 8
 
 extern const char *joystick_name[];
+#ifdef GCWZERO
+extern const char *joystick_name_gcw0[];
+#endif
 extern const char *joystick_connection[];
 #define JOYSTICK_CONN_COUNT 4
 
diff --git a/settings.dat b/settings.dat
index e6ad20c..f9b05fc 100644
--- a/settings.dat
+++ b/settings.dat
@@ -43,6 +43,7 @@
 accelerate_loader, boolean, 1
 slt_traps, boolean, 1,, slt, slttraps
 double_screen, null, 0
+triple_buffer, boolean, 0
 full_screen, boolean, 0
 writable_roms, boolean, 0
 autosave_settings, boolean, 0
@@ -142,6 +143,23 @@
 joystick_keyboard_left, numeric, 111
 joystick_keyboard_right, numeric, 112
 joystick_keyboard_fire, numeric, 32
+joystick_gcw0_output, numeric, 0
+joystick_gcw0_up, numeric, 0
+joystick_gcw0_down, numeric, 0
+joystick_gcw0_left, numeric, 0
+joystick_gcw0_right, numeric, 0
+joystick_gcw0_a, numeric, 0
+joystick_gcw0_b, numeric, 0
+joystick_gcw0_x, numeric, 0
+joystick_gcw0_y, numeric, 0
+joystick_gcw0_l1, numeric, 0
+joystick_gcw0_r1, numeric, 0
+joystick_gcw0_l2, numeric, 0
+joystick_gcw0_r2, numeric, 0
+joystick_gcw0_start, numeric, 0
+joystick_gcw0_select, numeric, 0
+joystick_gcw0_l3, numeric, 0
+joystick_gcw0_r3, numeric, 0
 
 keyboard_arrows_shifted, boolean, 1
 
diff --git a/sound/sdlsound.c b/sound/sdlsound.c
index 5e34c8f..d357152 100644
--- a/sound/sdlsound.c
+++ b/sound/sdlsound.c
@@ -93,7 +93,7 @@
      speed to about 2000% on my Mac, 100Hz allows up to 5000% for me) */
   if( hz > 100.0 ) hz = 100.0;
   sound_framesiz = *freqptr / hz;
-#ifdef __FreeBSD__
+#if defined(__FreeBSD__) || defined(GCWZERO)
   requested.samples = pow( 2.0, floor( log2( sound_framesiz ) ) );
 #else			/* #ifdef __FreeBSD__ */
   requested.samples = sound_framesiz;
diff --git a/timer/timer.c b/timer/timer.c
index 53e1070..f99536f 100644
--- a/timer/timer.c
+++ b/timer/timer.c
@@ -66,6 +66,12 @@
 timer_estimate_speed( void )
 {
   double current_time;
+#ifdef GCWZERO
+  static int frame_count = 0;
+  static float frames_per_second = 50;
+
+  frame_count++;
+#endif
 
   if( frames_until_update-- ) return 0;
 
@@ -77,14 +83,25 @@
     /* If we don't have enough data, assume we're running at the desired
        speed :-) */
     current_speed = settings_current.emulation_speed;
-
+#ifdef GCWZERO
+    frames_per_second = frame_count;
+#endif
   } else {
     current_speed = 10 * 100 /
                       ( current_time - stored_times[ next_stored_time ] );
+#ifdef GCWZERO
+    /* Each 10 seconds */
+    frames_per_second = 10 * frame_count /
+                      ( current_time - stored_times[ next_stored_time ] );
+#endif
   }
 
+#ifdef GCWZERO
+  ui_statusbar_update_speed( frames_per_second );
+  frame_count = 0;
+#else
   ui_statusbar_update_speed( current_speed );
-
+#endif
   stored_times[ next_stored_time ] = current_time;
 
   next_stored_time = ( next_stored_time + 1 ) % 10;
diff --git a/ui.c b/ui.c
index 282e0cc..39b6347 100644
--- a/ui.c
+++ b/ui.c
@@ -742,6 +742,13 @@
   filename = ui_get_save_filename( "Fuse - Write Tape" );
   if( !filename ) { fuse_emulation_unpause(); return 1; }
 
+#ifdef GCWZERO
+  /* Add the extension .TZX */
+  filename = realloc( filename, strlen( filename ) + 4 );
+  if( !filename ) { fuse_emulation_unpause(); return 1; }
+  strcat( filename, ".tzx" );
+#endif
+
   tape_write( filename );
 
   libspectrum_free( filename );
@@ -764,6 +771,13 @@
   if( saveas ) {
     filename = ui_get_save_filename( title );
     if( !filename ) { fuse_emulation_unpause(); return 1; }
+
+#ifdef GCWZERO
+    /* Add the extension .MDR */
+    filename = realloc( filename, strlen( filename ) + 4 );
+    if( !filename ) { fuse_emulation_unpause(); return 1; }
+    strcat( filename, ".mdr" );
+#endif
   }
 
   err = if1_mdr_write( which, filename );
@@ -787,6 +801,29 @@
 {
   return widget_end();
 }
+
+#ifdef GCWZERO
+void ui_widget_statusbar_update_info( float speed ) {
+  widget_statusbar_update_info( speed );
+}
+
+void ui_widget_statusbar_print_info( void ) {
+  widget_statusbar_print_info();
+}
+#endif
+
+#if VKEYBOARD
+void ui_widget_print_vkeyboard( void ) {
+  widget_vkeyboard_draw( NULL );
+}
+
+void ui_widget_input_vkeyboard( int native_key, int press ) {
+  if (press)
+    widget_vkeyboard_keyhandler( native_key );
+  else
+    widget_vkeyboard_keyrelease( native_key );
+}
+#endif
 #else
 int
 ui_widget_init( void )
diff --git a/ui/options.dat b/ui/options.dat
index bec99c7..76b60b9 100644
--- a/ui/options.dat
+++ b/ui/options.dat
@@ -15,8 +15,13 @@
 Checkbox, Black and white T(V), bw_tv, INPUT_KEY_v
 Checkbox, (P)AL-TV use TV2x effect, pal_tv2x, INPUT_KEY_p
 #ifdef UI_SDL
+#ifndef GCWZERO
 Checkbox, Full (s)creen, full_screen, INPUT_KEY_s
 #endif
+#ifdef GCWZERO
+Checkbox, Triple Bu(f)fer, triple_buffer, INPUT_KEY_f
+#endif
+#endif
 Checkbox, Show status(b)ar, statusbar, INPUT_KEY_b
 Checkbox, Snap (j)oystick prompt, joy_prompt, INPUT_KEY_j
 Checkbox, (C)onfirm actions, confirm_actions, INPUT_KEY_c
diff --git a/ui/sdl/sdldisplay.c b/ui/sdl/sdldisplay.c
index b78315b..77227d2 100644
--- a/ui/sdl/sdldisplay.c
+++ b/ui/sdl/sdldisplay.c
@@ -41,10 +41,29 @@
 #include "ui/scaler/scaler.h"
 #include "ui/uidisplay.h"
 #include "utils.h"
+#if VKEYBOARD
+#include "ui/vkeyboard.h"
+#endif
 
 SDL_Surface *sdldisplay_gc = NULL;   /* Hardware screen */
 static SDL_Surface *tmp_screen=NULL; /* Temporary screen for scalers */
 
+#if VKEYBOARD
+static SDL_Surface *keyb_screen = NULL;
+static SDL_Surface *keyb_screen_save = NULL;
+static int init_vkeyboard_canvas = 0;
+static SDL_Rect vkeyboard_position[6] = {
+  {16,   16,  0, 0},
+  {144,  16,  0, 0},
+  {16,   172, 0, 0},
+  {144,  172, 0, 0},
+  {80,   138,  0, 0},
+  {80,   64,  0, 0},
+};
+#define VKEYB_WIDTH  168
+#define VKEYB_HEIGHT 56
+#endif /* VKEYBOARD */
+
 static SDL_Surface *red_cassette[2], *green_cassette[2];
 static SDL_Surface *red_mdr[2], *green_mdr[2];
 static SDL_Surface *red_disk[2], *green_disk[2];
@@ -77,6 +96,12 @@
 
 static Uint32 bw_values[16];
 
+#if VKEYBOARD
+static Uint32 colour_values_a[17];
+static Uint32 bw_values_a[17];
+static int use_alpha_values = 0;
+#endif
+
 /* This is a rule of thumb for the maximum number of rects that can be updated
    each frame. If more are generated we just update the whole screen */
 #define MAX_UPDATE_RECT 300
@@ -95,6 +120,11 @@
 
 static libspectrum_byte sdldisplay_is_full_screen = 0;
 
+#ifdef GCWZERO
+static libspectrum_byte sdldisplay_is_triple_buffer = 0;
+static libspectrum_byte sdldisplay_change_triple_buffer = 0;
+#endif
+
 static int image_width;
 static int image_height;
 
@@ -103,6 +133,10 @@
 static void init_scalers( void );
 static int sdldisplay_allocate_colours( int numColours, Uint32 *colour_values,
                                         Uint32 *bw_values );
+#if VKEYBOARD
+static int sdldisplay_allocate_colours_alpha( int numColours, Uint32 *colour_values,
+                                             Uint32 *bw_values );
+#endif
 
 static int sdldisplay_load_gfx_mode( void );
 
@@ -116,7 +150,9 @@
   scaler_register( SCALER_SUPER2XSAI );
   scaler_register( SCALER_SUPEREAGLE );
   scaler_register( SCALER_ADVMAME2X );
+#ifndef GCWZERO
   scaler_register( SCALER_ADVMAME3X );
+#endif
   scaler_register( SCALER_DOTMATRIX );
   scaler_register( SCALER_PALTV );
   scaler_register( SCALER_HQ2X );
@@ -124,9 +160,16 @@
     scaler_register( SCALER_HALF ); 
     scaler_register( SCALER_HALFSKIP );
     scaler_register( SCALER_TIMEXTV );
+#ifndef GCWZERO
     scaler_register( SCALER_TIMEX1_5X );
     scaler_register( SCALER_TIMEX2X );
+#endif
   } else {
+#ifdef GCWZERO
+    scaler_register( SCALER_DOUBLESIZE );
+    scaler_register( SCALER_TV2X );
+    scaler_register( SCALER_PALTV2X );
+#else
     scaler_register( SCALER_DOUBLESIZE );
     scaler_register( SCALER_TRIPLESIZE );
     scaler_register( SCALER_QUADSIZE );
@@ -137,6 +180,7 @@
     scaler_register( SCALER_PALTV3X );
     scaler_register( SCALER_HQ3X );
     scaler_register( SCALER_HQ4X );
+#endif
   }
   
   if( scaler_is_supported( current_scaler ) ) {
@@ -225,10 +269,45 @@
   int i = 0, mw = 0, mh = 0, mn = 0;
 
   /* Get available fullscreen/software modes */
+#ifdef GCWZERO
+  modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_HWSURFACE);
+#else
   modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_SWSURFACE);
+#endif
 
   no_modes = ( modes == (SDL_Rect **) 0 || modes == (SDL_Rect **) -1 ) ? 1 : 0;
 
+#ifdef GCWZERO
+  settings_current.full_screen = 1;
+  sdldisplay_change_triple_buffer = settings_current.triple_buffer;
+  settings_current.sdl_fullscreen_mode = utils_safe_strdup( '\0' );
+/*
+ * Dirty hack. There should be a better solution.
+ * In RetroFW 1 the video driver don't downscale correctly. This is problematic
+ * with filters higher than 1x, the can be choosed but the image is not correct.
+ * This should prevent to use any filter that will be problematic.
+ * Also for Timex Machines this will force to use the Timex Half filters...
+ */
+  FILE* allow_downscaling = fopen("/sys/devices/platform/jz-lcd.0/allow_downscaling","r");
+  if (!allow_downscaling) {
+    FILE* os_release = fopen("/etc/os-release", "r");
+    if (os_release) {
+      char line[100];
+      char* ptok;
+      while ( fgets(line,sizeof(line),os_release) != NULL ) {
+        ptok = strtok(line,"=");
+        if (strcmp(ptok,"NAME") == 0) {
+          ptok = strtok(NULL,"=");
+          if (strcmp(ptok,"Buildroot\n") == 0)
+            settings_current.sdl_fullscreen_mode = utils_safe_strdup( "320x240" );
+          break;
+        }
+      }
+      fclose(os_release);
+    }
+  } else fclose(allow_downscaling);
+#endif
+
   if( settings_current.sdl_fullscreen_mode &&
       strcmp( settings_current.sdl_fullscreen_mode, "list" ) == 0 ) {
 
@@ -334,6 +413,37 @@
   return 0;
 }
 
+#if VKEYBOARD
+static int
+sdldisplay_allocate_colours_alpha( int numColours, Uint32 *colour_values,
+                                  Uint32 *bw_values ) {
+  int i;
+  Uint8 red, green, blue, grey;
+
+  for ( i = 0; i < numColours; i++ ) {
+
+      red = colour_palette[i].r;
+    green = colour_palette[i].g;
+     blue = colour_palette[i].b;
+
+    /* Addition of 0.5 is to avoid rounding errors */
+    grey = ( 0.299 * red + 0.587 * green + 0.114 * blue ) + 0.5;
+
+    colour_values[i] = SDL_MapRGBA( keyb_screen->format,  red, green, blue, 0xf0 );
+    bw_values[i]     = SDL_MapRGBA( keyb_screen->format, grey,  grey, grey, 0xf0 );
+  }
+
+    red = 0x60;
+  green = 0x60;
+   blue = 0x7a;
+   grey = ( 0.299 * red + 0.587 * green + 0.114 * blue ) + 0.5;
+  colour_values[16] = SDL_MapRGBA( keyb_screen->format,  red, green, blue, 0x50 );
+  bw_values[16]     = SDL_MapRGBA( keyb_screen->format, grey,  grey, grey, 0x50 );
+
+  return 0;
+}
+#endif /* VKEYBOARD */
+
 static void
 sdldisplay_find_best_fullscreen_scaler( void )
 {
@@ -387,6 +497,13 @@
     tmp_screen = NULL;
   }
 
+#if VKEYBOARD
+  if ( keyb_screen ) {
+    SDL_FreeSurface( keyb_screen );
+    keyb_screen = NULL;
+  }
+#endif
+
   tmp_screen_width = (image_width + 3);
 
   sdldisplay_current_size = scaler_get_scaling_factor( current_scaler );
@@ -394,14 +511,33 @@
   sdldisplay_find_best_fullscreen_scaler();
 
   /* Create the surface that contains the scaled graphics in 16 bit mode */
+#ifdef GCWZERO
+  Uint32 flags;
+  if (sdldisplay_change_triple_buffer)
+    flags = settings_current.full_screen ? (SDL_FULLSCREEN | SDL_HWSURFACE | SDL_TRIPLEBUF)
+    : (SDL_HWSURFACE | SDL_TRIPLEBUF);
+  else {
+    if (sdldisplay_is_triple_buffer) {
+      SDL_Flip( sdldisplay_gc );
+      uidisplay_frame_restore();
+      sdldisplay_force_full_refresh = 1;
+    }
+    flags = settings_current.full_screen ? (SDL_FULLSCREEN | SDL_HWSURFACE)
+    : SDL_HWSURFACE;
+  }
+#endif
   sdldisplay_gc = SDL_SetVideoMode(
     settings_current.full_screen && fullscreen_width ? fullscreen_width :
       image_width * sdldisplay_current_size,
     settings_current.full_screen && fullscreen_width ? max_fullscreen_height :
       image_height * sdldisplay_current_size,
     16,
+#ifdef GCWZERO
+    flags
+#else
     settings_current.full_screen ? (SDL_FULLSCREEN|SDL_SWSURFACE)
                                  : SDL_SWSURFACE
+#endif
   );
   if( !sdldisplay_gc ) {
     fprintf( stderr, "%s: couldn't create SDL graphics context\n", fuse_progname );
@@ -412,6 +548,11 @@
       !!( sdldisplay_gc->flags & ( SDL_FULLSCREEN | SDL_NOFRAME ) );
   sdldisplay_is_full_screen = settings_current.full_screen;
 
+#ifdef GCWZERO
+  sdldisplay_change_triple_buffer = !!( sdldisplay_gc->flags & SDL_TRIPLEBUF );
+  sdldisplay_is_triple_buffer = sdldisplay_change_triple_buffer;
+#endif
+
   /* Distinguish 555 and 565 mode */
   if( sdldisplay_gc->format->Gmask >> sdldisplay_gc->format->Gshift == 0x1f )
     scaler_select_bitformat( 555 );
@@ -436,12 +577,34 @@
     fuse_abort();
   }
 
+#if VKEYBOARD
+  /* Create the surface that contains the keyboard graphics in 32 bit mode */
+  SDL_Surface *swap_screen;
+  swap_screen = SDL_CreateRGBSurface(SDL_HWSURFACE,
+                                     machine_current->timex ? VKEYB_WIDTH * 2  : VKEYB_WIDTH,
+                                     machine_current->timex ? VKEYB_HEIGHT * 2 : VKEYB_HEIGHT,
+                                     16,
+                                     sdldisplay_gc->format->Rmask,
+                                     sdldisplay_gc->format->Gmask,
+                                     sdldisplay_gc->format->Bmask,
+                                     ( SDL_BYTEORDER == SDL_BIG_ENDIAN ? 0x000000ff : 0xff000000 ) );
+  if ( !swap_screen ) {
+    fprintf( stderr, "%s: couldn't create keyb_screen\n", fuse_progname );
+    fuse_abort();
+  }
+  keyb_screen = SDL_DisplayFormatAlpha( swap_screen );
+  SDL_FreeSurface( swap_screen );
+#endif
+
   fullscreen_x_off = ( sdldisplay_gc->w - image_width * sdldisplay_current_size ) *
                      sdldisplay_is_full_screen  / 2;
   fullscreen_y_off = ( sdldisplay_gc->h - image_height * sdldisplay_current_size ) *
                      sdldisplay_is_full_screen / 2;
 
   sdldisplay_allocate_colours( 16, colour_values, bw_values );
+#if VKEYBOARD
+  sdldisplay_allocate_colours_alpha( 16, colour_values_a, bw_values_a );
+#endif
 
   /* Redraw the entire screen... */
   display_refresh_all();
@@ -460,6 +623,13 @@
     SDL_FreeSurface( tmp_screen ); tmp_screen = NULL;
   }
 
+#if VKEYBOARD
+  if ( keyb_screen ) {
+    SDL_FreeSurface( keyb_screen );
+    keyb_screen = NULL;
+  }
+#endif
+
   /* Setup the new GFX mode */
   if( sdldisplay_load_gfx_mode() ) return 1;
 
@@ -615,6 +785,15 @@
 uidisplay_putpixel( int x, int y, int colour )
 {
   libspectrum_word *dest_base, *dest;
+
+#if VKEYBOARD
+  if (use_alpha_values) {
+    uidisplay_putpixel_alpha(x - DISPLAY_BORDER_ASPECT_WIDTH, y - DISPLAY_BORDER_HEIGHT,
+                             colour);
+    return;
+  }
+#endif
+
   Uint32 *palette_values = settings_current.bw_tv ? bw_values :
                            colour_values;
 
@@ -643,6 +822,122 @@
   }
 }
 
+#if VKEYBOARD
+/* Set one pixel in the display */
+void
+uidisplay_putpixel_alpha( int x, int y, int colour ) {
+  libspectrum_dword *dest_base, *dest;
+  Uint32 *palette_values = settings_current.bw_tv ? bw_values_a :
+      colour_values_a;
+  Uint32 palette_colour = palette_values[ colour ];
+
+  if ( machine_current->timex ) {
+    x <<= 1;
+    y <<= 1;
+    dest_base = dest =
+        (libspectrum_dword*) ( (libspectrum_byte*) keyb_screen->pixels +
+        (x) * keyb_screen->format->BytesPerPixel +
+        (y) * keyb_screen->pitch);
+
+    *(dest++) = palette_colour;
+    *(dest++) = palette_colour;
+    dest = (libspectrum_dword*)
+        ( (libspectrum_byte*) dest_base + keyb_screen->pitch);
+    *(dest++) = palette_colour;
+    *(dest++) = palette_colour;
+  } else {
+    dest =
+        (libspectrum_dword*) ( (libspectrum_byte*) keyb_screen->pixels +
+        (x) * keyb_screen->format->BytesPerPixel +
+        (y) * keyb_screen->pitch);
+
+    *dest = palette_colour;
+  }
+}
+
+void
+uidisplay_vkeyboard( void (*print_fn)(void), int position ) {
+  static int old_position = -1;
+  int current_position;
+
+  if (ui_widget_level >= 0)
+    current_position = 4;
+  else
+    current_position = position;
+
+  SDL_Rect r1 = { machine_current->timex ? vkeyboard_position[current_position].x * 2 : vkeyboard_position[current_position].x,
+                  machine_current->timex ? vkeyboard_position[current_position].y * 2 : vkeyboard_position[current_position].y,
+                  machine_current->timex ? VKEYB_WIDTH * 2  : VKEYB_WIDTH,
+                  machine_current->timex ? VKEYB_HEIGHT * 2 : VKEYB_HEIGHT };
+
+#ifdef GCWZERO
+  if ( !init_vkeyboard_canvas ) {
+    SDL_FillRect(keyb_screen, NULL, settings_current.bw_tv ? bw_values_a[16] : colour_values_a[16]);
+    init_vkeyboard_canvas = 1;
+  }
+#endif
+
+  if (ui_widget_level >= 0) {
+    if (!keyb_screen_save) {
+      keyb_screen_save = SDL_CreateRGBSurface(tmp_screen->flags, r1.w, r1.h,
+                                              tmp_screen->format->BitsPerPixel,
+                                              tmp_screen->format->Rmask,
+                                              tmp_screen->format->Gmask,
+                                              tmp_screen->format->Bmask,
+                                              tmp_screen->format->Amask);
+      SDL_BlitSurface(tmp_screen, &r1, keyb_screen_save, NULL);
+    } else
+      SDL_BlitSurface(keyb_screen_save, NULL, tmp_screen, &r1);
+  }
+
+  use_alpha_values = 1;
+  print_fn();
+  use_alpha_values = 0;
+
+  SDL_BlitSurface(keyb_screen, NULL, tmp_screen, &r1);
+
+  updated_rects[num_rects].x = r1.x;
+  updated_rects[num_rects].y = r1.y;
+  updated_rects[num_rects].w = r1.w;
+  updated_rects[num_rects].h = r1.h;
+  num_rects++;
+
+  if (ui_widget_level == -1) {
+    if (old_position != position)
+      display_refresh_all();
+    else
+      display_refresh_rect(r1.x, r1.y, r1.w, r1.h );
+    old_position = position;
+  }
+}
+
+void
+uidisplay_vkeyboard_input( void (*input_fn)(input_key key), input_key key ) {
+  input_fn(key);
+}
+
+void
+uidisplay_vkeyboard_release( void (*release_fn)(input_key key), input_key key ) {
+  release_fn(key);
+}
+
+void
+uidisplay_vkeyboard_end( void ) {
+  init_vkeyboard_canvas = 0;
+  if (keyb_screen_save) {
+    SDL_FreeSurface(keyb_screen_save);
+    keyb_screen_save = NULL;
+  }
+  /*
+     Don't refresh display from the use of keyboard in other Widgets
+     The function widget_do already do a display_refresh_call at his end
+     And the call here will affect to some operations like save screens
+   */
+  if (ui_widget_level == -1)
+    display_refresh_all();
+}
+#endif /* VKEYBOARD */
+
 /* Print the 8 pixels in `data' using ink colour `ink' and paper
    colour `paper' to the screen at ( (8*x) , y ) */
 void
@@ -763,14 +1058,38 @@
   /* We check for a switch to fullscreen here to give systems with a
      windowed-only UI a chance to free menu etc. resources before
      the switch to fullscreen (e.g. Mac OS X) */
+#ifdef GCWZERO
+  sdldisplay_change_triple_buffer = settings_current.triple_buffer;
+  if ( ( sdldisplay_is_full_screen != settings_current.full_screen  ||
+      sdldisplay_is_triple_buffer != sdldisplay_change_triple_buffer ) &&
+#else
   if( sdldisplay_is_full_screen != settings_current.full_screen &&
+#endif
       uidisplay_hotswap_gfx_mode() ) {
     fprintf( stderr, "%s: Error switching to fullscreen\n", fuse_progname );
     fuse_abort();
   }
 
+#ifdef GCWZERO
+  settings_current.triple_buffer = sdldisplay_change_triple_buffer;
+ #endif
+
+#if VKEYBOARD
+  if ( vkeyboard_enabled )
+    ui_widget_print_vkeyboard();
+#endif
+
+#ifdef GCWZERO
+  if ( settings_current.statusbar )
+    ui_widget_statusbar_print_info();
+#endif
+
   /* Force a full redraw if requested */
+#ifdef GCWZERO
+  if ( sdldisplay_force_full_refresh || sdldisplay_is_triple_buffer ) {
+#else
   if ( sdldisplay_force_full_refresh ) {
+#endif
     num_rects = 1;
 
     updated_rects[0].x = 0;
@@ -820,6 +1139,11 @@
   if( SDL_MUSTLOCK( sdldisplay_gc ) ) SDL_UnlockSurface( sdldisplay_gc );
 
   /* Finally, blit all our changes to the screen */
+#ifdef GCWZERO
+  if ( sdldisplay_is_triple_buffer )
+    SDL_Flip( sdldisplay_gc );
+  else
+#endif
   SDL_UpdateRects( sdldisplay_gc, num_rects, updated_rects );
 
   num_rects = 0;
@@ -866,6 +1190,13 @@
     SDL_FreeSurface( saved ); saved = NULL;
   }
 
+#if VKEYBOARD
+  if ( keyb_screen ) {
+    SDL_FreeSurface( keyb_screen );
+    keyb_screen = NULL;
+  }
+#endif
+
   for( i=0; i<2; i++ ) {
     if ( red_cassette[i] ) {
       SDL_FreeSurface( red_cassette[i] ); red_cassette[i] = NULL;
diff --git a/ui/sdl/sdlui.c b/ui/sdl/sdlui.c
index 090f44e..b905667 100644
--- a/ui/sdl/sdlui.c
+++ b/ui/sdl/sdlui.c
@@ -37,6 +37,13 @@
 #include "sdlkeyboard.h"
 #include "ui/scaler/scaler.h"
 #include "menu.h"
+#if VKEYBOARD
+#include "ui/vkeyboard.h"
+#endif
+
+#ifdef GCWZERO
+static Uint8 *keys_state;
+#endif
 
 static void
 atexit_proc( void )
@@ -68,6 +75,10 @@
 
   ui_mouse_present = 1;
 
+#ifdef GCWZERO
+  keys_state = SDL_GetKeyState(NULL);
+#endif
+
   return 0;
 }
 
@@ -75,6 +86,17 @@
 ui_event( void )
 {
   SDL_Event event;
+#if VKEYBOARD
+  int vkeyboard_enabled_old = vkeyboard_enabled;
+#endif
+#ifdef GCWZERO
+  SDL_PumpEvents();
+  /* L1 + R1 + X: Toggle triple buffer */
+  if ( keys_state[SDLK_BACKSPACE] && keys_state[SDLK_TAB] && keys_state[SDLK_SPACE] ) {
+    settings_current.triple_buffer = !settings_current.triple_buffer;
+    return 0;
+  }
+#endif
 
   while ( SDL_PollEvent( &event ) ) {
     switch ( event.type ) {
@@ -134,6 +156,11 @@
     }
   }
 
+#if VKEYBOARD
+  if ( vkeyboard_enabled_old && !vkeyboard_enabled )
+    uidisplay_vkeyboard_end();
+#endif
+
   return 0;
 }
 
@@ -163,6 +190,10 @@
 
   snprintf( buffer, 15, "%s - %3.0f%%", fuse, speed );
 
+#ifdef GCWZERO
+  if ( settings_current.statusbar )
+    ui_widget_statusbar_update_info( speed );
+#endif
   /* FIXME: Icon caption should be snapshot name? */
   SDL_WM_SetCaption( buffer, fuse );
 
diff --git a/ui/ui.h b/ui/ui.h
index a53cb2b..b728f26 100644
--- a/ui/ui.h
+++ b/ui/ui.h
@@ -302,6 +302,15 @@
 /* Code called at start and end of emulation if widget system is used */
 int ui_widget_init( void );
 int ui_widget_end( void );
+#ifdef GCWZERO
+void ui_widget_statusbar_update_info( float speed );
+void ui_widget_statusbar_print_info( void );
+#endif
+#if VKEYBOARD
+extern int vkeyboard_enabled;
+void ui_widget_print_vkeyboard( void );
+void ui_widget_input_vkeyboard( int native_key, int press );
+#endif
 
 /* How many levels deep have we recursed through widgets; -1 => none */
 extern int ui_widget_level;
diff --git a/ui/uijoystick.h b/ui/uijoystick.h
index 6a39ead..b06efef 100644
--- a/ui/uijoystick.h
+++ b/ui/uijoystick.h
@@ -34,7 +34,11 @@
 #ifndef FUSE_UI_UIJOYSTICK_H
 #define FUSE_UI_UIJOYSTICK_H
 
+#ifdef GCWZERO
+#define NUM_JOY_BUTTONS 16
+#else
 #define NUM_JOY_BUTTONS 15
+#endif
 
 int ui_joystick_init( void ); /* returns no. of joysticks initialised */
 void ui_joystick_end( void );
diff --git a/ui/vkeyboard.h b/ui/vkeyboard.h
new file mode 100644
index 0000000..f62cf9a
--- /dev/null
+++ b/ui/vkeyboard.h
@@ -0,0 +1,40 @@
+/* vkeyboard.h: Virtual Keyboard
+   Copyright (c) 2020 Pedro Luis Rodríguez González
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   E-mail: pl.rguez@gmail.com
+
+*/
+
+#ifndef FUSE_VKEYBOARD_H
+#define FUSE_VKEYBOARD_H
+
+#include <config.h>
+
+#if VKEYBOARD
+#include <libspectrum.h>
+#include "input.h"
+
+extern int vkeyboard_enabled;
+void uidisplay_putpixel_alpha( int x, int y, int colour );
+void uidisplay_vkeyboard( void (*print_fn)(void), int position );
+void uidisplay_vkeyboard_input( void (*input_fn)(input_key key), input_key key);
+void uidisplay_vkeyboard_release( void (*release_fn)(input_key key), input_key key);
+void uidisplay_vkeyboard_end( void);
+#endif
+#endif			/* #ifndef FUSE_VKEYBOARD_H */
diff --git a/ui/widget/Makefile.am b/ui/widget/Makefile.am
index 7d9ed1f..7442c9d 100644
--- a/ui/widget/Makefile.am
+++ b/ui/widget/Makefile.am
@@ -51,6 +51,7 @@
                   ui/widget/roms.c \
                   ui/widget/select.c \
                   ui/widget/text.c \
+                  ui/widget/vkeyboard.c \
                   ui/widget/widget_internals.h \
                   ui/widget/widget.c \
                   ui/widget/widget.h
diff --git a/ui/widget/about.c b/ui/widget/about.c
index 18bd87b..2fccd19 100644
--- a/ui/widget/about.c
+++ b/ui/widget/about.c
@@ -73,12 +73,24 @@
 widget_about_keyhandler( input_key key )
 {
   switch( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_OK );
+    return;
+#endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/binary.c b/ui/widget/binary.c
index c2b65f5..e5de175 100644
--- a/ui/widget/binary.c
+++ b/ui/widget/binary.c
@@ -280,6 +280,9 @@
     break;
 #endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_c:
   case INPUT_KEY_C:
   case INPUT_KEY_Escape:
@@ -330,6 +333,9 @@
       new_highlight_entry = 0;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/browse.c b/ui/widget/browse.c
index 7859e01..bbb913c 100644
--- a/ui/widget/browse.c
+++ b/ui/widget/browse.c
@@ -142,6 +142,16 @@
     break;
 #endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_OK );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
@@ -173,13 +183,21 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Page_Up:
+#endif
     highlight -= 18; if( highlight < 0 ) highlight = 0;
     top_line  -= 18; if( top_line  < 0 ) top_line = 0;
     show_blocks();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_Page_Down:
+#endif
     highlight += 18;
     if( highlight >= block_count ) highlight = block_count - 1;
     top_line += 18;
@@ -190,17 +208,28 @@
     show_blocks();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Up:
+#else
   case INPUT_KEY_Home:
+#endif
     highlight = top_line = 0;
     show_blocks();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Down:
+#else
   case INPUT_KEY_End:
+#endif
     highlight = block_count - 1;
     top_line = block_count - 18; if( top_line < 0 ) top_line = 0;
     show_blocks();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/debugger.c b/ui/widget/debugger.c
index cc5ae52..019c7d1 100644
--- a/ui/widget/debugger.c
+++ b/ui/widget/debugger.c
@@ -88,6 +88,9 @@
 
 int ui_debugger_deactivate( int interruptible GCC_UNUSED )
 {
+#if VKEYBOARD
+  vkeyboard_enabled = 0;
+#endif
   /* Refresh the Spectrum's display, including the border */
   display_refresh_all();
   return widget_end_all( WIDGET_FINISHED_OK );
@@ -117,7 +120,9 @@
   };
   int x;
   char pbuf[8];
-
+#if VKEYBOARD
+  vkeyboard_enabled = 1;
+#endif
   widget_rectangle( LC(0), LR(0), 40 * 8, 17 * 8 + 4, 1 );
   widget_rectangle( LC(0), LR(17) + 2, 320, 1, 7 );
 
@@ -163,11 +168,24 @@
 {
   /* Display mode */
   switch ( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_OK );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:	/* Close widget */
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     debugger_run();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_c:
   case INPUT_KEY_Return:	/* Close widget */
   case INPUT_KEY_KP_Enter:
@@ -231,20 +249,36 @@
     scroll( 1 );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Page_Up:	/* Back eight lines */
+#endif
     scroll( -8 );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_Page_Down:	/* Forward eight lines */
+#endif
     scroll( 8 );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Up:
+#else
   case INPUT_KEY_Home:		/* To start of memory */
+#endif
     debugger_memaddr = 0;
     scroll( 0 );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Down:
+#else
   case INPUT_KEY_End:		/* To end of RAM */
+#endif
     debugger_memaddr = 0;
     scroll( -8 );
     break;
diff --git a/ui/widget/error.c b/ui/widget/error.c
index d293380..9fdaec5 100644
--- a/ui/widget/error.c
+++ b/ui/widget/error.c
@@ -165,10 +165,16 @@
 {
   switch( key ) {
 
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
     widget_end_widget( WIDGET_FINISHED_OK );
diff --git a/ui/widget/filesel.c b/ui/widget/filesel.c
index 86f42f9..c6efe8f 100644
--- a/ui/widget/filesel.c
+++ b/ui/widget/filesel.c
@@ -138,7 +138,10 @@
   }
   if( widget_filesel_name )
     filename = utils_safe_strdup( widget_filesel_name );
-
+#ifdef GCWZERO
+  if ( filename )
+    last_filename = utils_last_filename( filename );
+#endif
   return filename;
   
 }
@@ -607,6 +610,10 @@
     widget_print_title( 24, WIDGET_COLOUR_FOREGROUND, dir );
   }
 
+#ifdef GCWZERO
+  widget_print_filetitle( 32, widget_filenames[ current ], is_saving );
+#endif
+
   if( top_left ) widget_up_arrow( 1, 5, WIDGET_COLOUR_FOREGROUND );
 
   /* Print the filenames, mostly normally, but with the currently
@@ -622,9 +629,17 @@
   if( is_saving )
   {
     widget_printstring( 12, 22 * 8, WIDGET_COLOUR_FOREGROUND,
+#ifdef GCWZERO
+				     "\012A\001 = select" );
+#else
 				     "\012RETURN\001 = select" );
+#endif
     widget_printstring_right( 244, 22 * 8, WIDGET_COLOUR_FOREGROUND,
+#ifdef GCWZERO
+					   "\012X\001 = enter name" );
+#else
 					   "\012TAB\001 = enter name" );
+#endif
   }
 
   if( i < n )
@@ -844,7 +859,17 @@
 				top_left_file, current_file        );
     break;
 #endif
-    
+
+#ifdef GCWZERO
+  case INPUT_KEY_Home: /* Power   */
+  case INPUT_KEY_End:  /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
@@ -878,32 +903,57 @@
     if( current_file < widget_numfiles-1 ) new_current_file++;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab: /* L1 */
+#else
   case INPUT_KEY_Page_Up:
+#endif
     new_current_file = ( current_file > ENTRIES_PER_SCREEN ) ?
                        current_file - ENTRIES_PER_SCREEN     :
                        0;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace: /* R1 */
+#else
   case INPUT_KEY_Page_Down:
+#endif
     new_current_file = current_file + ENTRIES_PER_SCREEN;
     if( new_current_file >= widget_numfiles )
       new_current_file = widget_numfiles - 1;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Up:  /* L2 */
+#else
   case INPUT_KEY_Home:
+#endif
     new_current_file = 0;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Down: /* R2 */
+#else
   case INPUT_KEY_End:
+#endif
     new_current_file = widget_numfiles - 1;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_space: /* X */
+#else
   case INPUT_KEY_Tab:
+#endif
     if( is_saving ) {
       widget_text_t text_data;
       text_data.title = title;
       text_data.allow = WIDGET_INPUT_ASCII;
       text_data.max_length = 30;
+#ifdef GCWZERO
+      if (last_filename)
+        snprintf( text_data.text, 30, "%s", last_filename );
+      else
+#endif
       text_data.text[0] = 0;
       if( widget_do_text( &text_data ) ||
 	  !widget_text_text || !*widget_text_text      )
@@ -935,6 +985,9 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
@@ -991,6 +1044,10 @@
       /* Otherwise, print the current file uninverted and the
 	 new current file inverted */
 
+#ifdef GCWZERO
+      widget_print_filetitle( 32, widget_filenames[ new_current_file ], is_saving );
+#endif
+
       widget_print_filename( widget_filenames[ current_file ],
 			     current_file - top_left_file, 0 );
 	  
diff --git a/ui/widget/memory.c b/ui/widget/memory.c
index 726df28..ff05cd8 100644
--- a/ui/widget/memory.c
+++ b/ui/widget/memory.c
@@ -71,10 +71,23 @@
 widget_memory_keyhandler( input_key key )
 {
   switch ( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:	/* Close widget */
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:	/* Close widget */
   case INPUT_KEY_KP_Enter:
     widget_end_all( WIDGET_FINISHED_OK );
@@ -85,13 +98,29 @@
     memaddr -= 16;    widget_memory_draw( NULL ); break;
   case INPUT_KEY_Down:
     memaddr += 16;    widget_memory_draw( NULL ); break;
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Page_Up:
+#endif
     memaddr -= 128;   widget_memory_draw( NULL ); break;
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_Page_Down:
+#endif
     memaddr += 128;   widget_memory_draw( NULL ); break;
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Up:
+#else
   case INPUT_KEY_Home:
+#endif
     memaddr = 0;      widget_memory_draw( NULL ); break;
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Down:
+#else
   case INPUT_KEY_End:
+#endif
     memaddr = 0xFF80; widget_memory_draw( NULL ); break;
 
   default:;
diff --git a/ui/widget/menu.c b/ui/widget/menu.c
index 22e990e..5687400 100644
--- a/ui/widget/menu.c
+++ b/ui/widget/menu.c
@@ -52,8 +52,30 @@
 widget_menu_entry *menu;
 static size_t highlight_line = 0;
 static size_t count;
+#ifdef GCWZERO
+static int *current_settings[ 17 ];
+#else
 static int *current_settings[ 16 ];
+#endif
 
+#ifdef GCWZERO
+#define GET_SET_KEY_FUNCTIONS( which ) \
+\
+static void \
+set_key_for_button_ ## which ( int action ) \
+{ \
+  *current_settings[ which ] = action; \
+  int number_widgets = widgets_to_end; \
+  widgets_to_end = 0; \
+  widget_end_n_widgets( number_widgets, WIDGET_FINISHED_OK ); \
+} \
+\
+static const char* \
+get_key_name_for_button_ ## which ( void ) \
+{ \
+  return keyboard_key_text( *current_settings[ which ] ); \
+}
+#else
 #define GET_SET_KEY_FUNCTIONS( which ) \
 \
 static void \
@@ -68,6 +90,7 @@
 { \
   return keyboard_key_text( *current_settings[ which ] ); \
 }
+#endif
 
 GET_SET_KEY_FUNCTIONS( 1 )
 GET_SET_KEY_FUNCTIONS( 2 )
@@ -86,6 +109,9 @@
 GET_SET_KEY_FUNCTIONS( 13 )
 GET_SET_KEY_FUNCTIONS( 14 )
 GET_SET_KEY_FUNCTIONS( 15 )
+#ifdef GCWZERO
+GET_SET_KEY_FUNCTIONS( 16 )
+#endif  /* #ifdef GCWZERO */
 #endif  /* #ifndef GEKKO */
 #endif  /* #ifdef USE_JOYSTICK */
 
@@ -173,12 +199,29 @@
 SUBMENU_KEY_SELECTIONS( 13 )
 SUBMENU_KEY_SELECTIONS( 14 )
 SUBMENU_KEY_SELECTIONS( 15 )
+#ifdef GCWZERO
+SUBMENU_KEY_SELECTIONS( 16 )
+#endif
 #endif  /* #ifndef GEKKO */
 #endif  /* #ifdef USE_JOYSTICK */
 
 #ifdef USE_JOYSTICK
 static widget_menu_entry submenu_joystick_buttons[] = {
   { "Select joystick button" },
+#ifdef GCWZERO
+  { "Button \012A\011", INPUT_KEY_1, submenu_select_key_for_button_1, NULL, get_key_name_for_button_1, 0 },
+  { "Button \012B\011", INPUT_KEY_2, submenu_select_key_for_button_2, NULL, get_key_name_for_button_2, 0 },
+  { "Button \012X\011", INPUT_KEY_3, submenu_select_key_for_button_3, NULL, get_key_name_for_button_3, 0 },
+  { "Button \012Y\011", INPUT_KEY_4, submenu_select_key_for_button_4, NULL, get_key_name_for_button_4, 0 },
+  { "Button \012L1\011", INPUT_KEY_5, submenu_select_key_for_button_5, NULL, get_key_name_for_button_5, 0 },
+  { "Button \012R1\011", INPUT_KEY_6, submenu_select_key_for_button_6, NULL, get_key_name_for_button_6, 0 },
+  { "Button \012L2\011", INPUT_KEY_7, submenu_select_key_for_button_7, NULL, get_key_name_for_button_7, 0 },
+  { "Button \012R2\011", INPUT_KEY_8, submenu_select_key_for_button_8, NULL, get_key_name_for_button_8, 0 },
+  { "Button \012START\011", INPUT_KEY_9, submenu_select_key_for_button_9, NULL, get_key_name_for_button_9, 0 },
+  { "Button \012SELECT\011", INPUT_KEY_0, submenu_select_key_for_button_10, NULL, get_key_name_for_button_10, 0 },
+  { "Button \012L3\011", INPUT_KEY_a, submenu_select_key_for_button_11, NULL, get_key_name_for_button_11, 0 },
+  { "Button \012R3\011", INPUT_KEY_b, submenu_select_key_for_button_12, NULL, get_key_name_for_button_12, 0 },
+#else
 #ifndef GEKKO
   { "Button \0121\011", INPUT_KEY_1, submenu_select_key_for_button_1, NULL, get_key_name_for_button_1, 0 },
   { "Button \0122\011", INPUT_KEY_2, submenu_select_key_for_button_2, NULL, get_key_name_for_button_2, 0 },
@@ -205,6 +248,7 @@
   { "Button \012Z\011 on Nunchuck", INPUT_KEY_z, submenu_select_key_for_button_7, NULL, get_key_name_for_button_7, 0 },
   { "Button \012C\011 on Nunchuck", INPUT_KEY_c, submenu_select_key_for_button_8, NULL, get_key_name_for_button_8, 0 },
 #endif  /* #ifndef GEKKO */
+#endif  /* ifdef GCWZERO */
   { NULL }
 };
 #endif  /* #ifdef USE_JOYSTICK */
@@ -219,6 +263,29 @@
   { NULL }
 };
 
+#ifdef GCWZERO
+static widget_menu_entry submenu_gcw0_keys_buttons[] = {
+  { "Map GCW0 to keyboard key" },
+  { "Button \012U\011p", INPUT_KEY_u, submenu_select_key_for_button_1, NULL, get_key_name_for_button_1, 0 },
+  { "Button \012D\011own", INPUT_KEY_d, submenu_select_key_for_button_2, NULL, get_key_name_for_button_2, 0 },
+  { "Button \012L\011eft", INPUT_KEY_l, submenu_select_key_for_button_3, NULL, get_key_name_for_button_3, 0 },
+  { "Button \012R\011ight", INPUT_KEY_r, submenu_select_key_for_button_4, NULL,	get_key_name_for_button_4, 0 },
+  { "Button \012A\011 Button", INPUT_KEY_a, submenu_select_key_for_button_5, NULL, get_key_name_for_button_5, 0 },
+  { "Button \012B\011 Button", INPUT_KEY_b, submenu_select_key_for_button_6, NULL, get_key_name_for_button_6, 0 },
+  { "Button \012X\011 Button", INPUT_KEY_x, submenu_select_key_for_button_7, NULL, get_key_name_for_button_7, 0 },
+  { "Button \012Y\011 Button", INPUT_KEY_y, submenu_select_key_for_button_8, NULL, get_key_name_for_button_8, 0 },
+  { "Button \012L1\011 Button", INPUT_KEY_1, submenu_select_key_for_button_9, NULL, get_key_name_for_button_9, 0 },
+  { "Button \012R1\011 Button", INPUT_KEY_2, submenu_select_key_for_button_10, NULL, get_key_name_for_button_10, 0 },
+  { "Button \012L2\011 Button", INPUT_KEY_3, submenu_select_key_for_button_11, NULL, get_key_name_for_button_11, 0 },
+  { "Button \012R2\011 Button", INPUT_KEY_4, submenu_select_key_for_button_12, NULL, get_key_name_for_button_12, 0 },
+  { "Button \012START\011 Button", INPUT_KEY_5, submenu_select_key_for_button_13, NULL, get_key_name_for_button_13, 0 },
+  { "Button \012SELECT\011 Button", INPUT_KEY_6, submenu_select_key_for_button_14, NULL, get_key_name_for_button_14, 0 },
+  { "Button \012L3\011 Button", INPUT_KEY_7, submenu_select_key_for_button_15, NULL, get_key_name_for_button_15, 0 },
+  { "Button \012R3\011 Button", INPUT_KEY_8, submenu_select_key_for_button_16, NULL, get_key_name_for_button_16, 0 },
+  { NULL }
+};
+#endif  /* ifdef GCWZERO */
+
 #define MAX_JOYSTICK_TYPES 8
 /* joystick types + title of the window + NULL */
 static widget_menu_entry submenu_types[ MAX_JOYSTICK_TYPES + 2 ];
@@ -238,6 +305,19 @@
 SUBMENU_DEVICE_SELECTIONS( joystick )
 #endif  /* #ifdef USE_JOYSTICK */
 SUBMENU_DEVICE_SELECTIONS( keyboard )
+#ifdef GCWZERO
+static widget_menu_entry submenu_types_gcw0[ 4 ];
+static char joystick_names_gcw0[ 2 ][ 100 ];
+#define SUBMENU_DEVICE_SELECTIONS_GCW0( device ) \
+\
+static widget_menu_entry submenu_type_and_mapping_for_ ## device [] = { \
+  { "Select type or map buttons" }, \
+  { "\012T\011ype", INPUT_KEY_t, submenu_types_gcw0, set_joystick_type, NULL, 0 }, \
+  { "\012B\011utton Mapping", INPUT_KEY_b, submenu_ ## device ## _buttons, NULL, NULL, 0 }, \
+  { NULL } \
+};
+SUBMENU_DEVICE_SELECTIONS_GCW0( gcw0_keys )
+#endif
 
 static void
 print_items( void )
@@ -324,18 +404,44 @@
     widget_menu_draw( menu );
     break;
 #endif
-    
+
+#ifdef GCWZERO
+  case INPUT_KEY_Home: /* Power */
+  case INPUT_KEY_End:  /* RetroFW */
+#ifdef GCWZERO
+    widgets_to_end = 0;
+#endif
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
+#ifdef GCWZERO
+    if (widgets_to_end) widgets_to_end--;
+#endif
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
     ptr=&menu[1 + highlight_line];
     if(!ptr->inactive) {
       if( ptr->submenu ) {
+#ifdef GCWZERO
+        if (widgets_to_end ||
+            strcmp(menu->text,"Select joystick button")==0 ||
+            strcmp(menu->text,"Map GCW0 to keyboard key")==0 ||
+            strcmp(menu->text,"Select keyboard key")==0 )
+          widgets_to_end++;
+#endif
         widget_do_menu( ptr->submenu );
       } else {
         ptr->callback( ptr->action );
@@ -361,7 +467,11 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab: /* L1 */
+#else
   case INPUT_KEY_Home:
+#endif
     new_highlight_line = 0;
     ptr = &menu[1 + new_highlight_line];
     while( new_highlight_line < (ptrdiff_t)count - 1 && ptr->inactive ) {
@@ -371,7 +481,11 @@
     cursor_pressed = 1;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace: /* R1 */
+#else
   case INPUT_KEY_End:
+#endif
     new_highlight_line = (ptrdiff_t)count - 1;
     ptr = &menu[1 + new_highlight_line];
     while( new_highlight_line > 0 && ptr->inactive ) {
@@ -571,6 +685,29 @@
     current_settings[ 5 ] = &( settings_current.joystick_keyboard_fire );
     submenu_type_and_mapping_for_keyboard[ 1 ].detail = menu_keyboard_joystick_detail;
     break;
+
+#ifdef GCWZERO
+  case GCW0_KEYBOARD:
+    current_settings[ 0 ] = &( settings_current.joystick_gcw0_output );
+    current_settings[ 1 ] = &( settings_current.joystick_gcw0_up );
+    current_settings[ 2 ] = &( settings_current.joystick_gcw0_down );
+    current_settings[ 3 ] = &( settings_current.joystick_gcw0_left );
+    current_settings[ 4 ] = &( settings_current.joystick_gcw0_right );
+    current_settings[ 5 ] = &( settings_current.joystick_gcw0_a );
+    current_settings[ 6 ] = &( settings_current.joystick_gcw0_b );
+    current_settings[ 7 ] = &( settings_current.joystick_gcw0_x );
+    current_settings[ 8 ] = &( settings_current.joystick_gcw0_y );
+    current_settings[ 9 ] = &( settings_current.joystick_gcw0_l1 );
+    current_settings[ 10 ] = &( settings_current.joystick_gcw0_r1 );
+    current_settings[ 11 ] = &( settings_current.joystick_gcw0_l2 );
+    current_settings[ 12 ] = &( settings_current.joystick_gcw0_r2 );
+    current_settings[ 13 ] = &( settings_current.joystick_gcw0_start );
+    current_settings[ 14 ] = &( settings_current.joystick_gcw0_select );
+    current_settings[ 15 ] = &( settings_current.joystick_gcw0_l3 );
+    current_settings[ 16 ] = &( settings_current.joystick_gcw0_r3 );
+    submenu_type_and_mapping_for_gcw0_keys[ 1 ].detail = menu_gcw0_keyboard_detail;
+    break;
+#endif
   }
 
   /* Populate joystick names */
@@ -589,9 +726,27 @@
   }
   submenu_types[ i + 1 ].text = NULL;
 
+#ifdef GCWZERO
+  submenu_types_gcw0[ 0 ].text = "Activate joystick";
+  for( i = 0; i < 2; i++ ) {
+    char shortcut[ 2 ] = { 'A' + i, '\0' };
+    snprintf( ( char * ) joystick_names_gcw0[ i ], 100, "\012%s\011 %s", shortcut,
+              joystick_name_gcw0[ i ] );
+    submenu_types_gcw0[ i + 1 ].text = joystick_names_gcw0[ i ];
+    submenu_types_gcw0[ i + 1 ].key = INPUT_KEY_a + i;
+    submenu_types_gcw0[ i + 1 ].callback = set_joystick_type;
+    submenu_types_gcw0[ i + 1 ].action = i;
+  }
+  submenu_types_gcw0[ i + 1 ].text = NULL;
+#endif
+
   if( action - 1 == JOYSTICK_KEYBOARD ) 
     error = widget_do_menu( submenu_type_and_mapping_for_keyboard );
 
+#ifdef GCWZERO
+  else if ( action - 1 == GCW0_KEYBOARD )
+    error = widget_do_menu( submenu_type_and_mapping_for_gcw0_keys );
+#endif
 #ifdef USE_JOYSTICK
   else
     error = widget_do_menu( submenu_type_and_mapping_for_joystick );
@@ -604,7 +759,11 @@
 set_joystick_type( int action )
 {
   *current_settings[ 0 ] = action;
+#ifdef GCWZERO
+  widget_end_widget( WIDGET_FINISHED_OK );
+#else
   widget_end_all( WIDGET_FINISHED_OK );
+#endif
 }
 
 /* Options/Select ROMs/<type> */
@@ -749,6 +908,14 @@
   widget_do_about();
 }
 
+#if VKEYBOARD
+void
+menu_vkeyboard( int action )
+{
+  widget_do_vkeyboard();
+}
+#endif
+
 static int
 set_active( struct widget_menu_entry *menu, const char *path, int active )
 {
diff --git a/ui/widget/options.pl b/ui/widget/options.pl
index 7bc34a6..b4b5d2b 100755
--- a/ui/widget/options.pl
+++ b/ui/widget/options.pl
@@ -580,7 +580,10 @@
     widget_$_->{name}_show_all( &widget_options_settings );
     break;
 #endif
-    
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
@@ -605,14 +608,22 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Home:
+#endif
     if ( highlight_line ) {
       new_highlight_line = 0;
       cursor_pressed = 1;
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_End:
+#endif
     if ( highlight_line + 2 < $count ) {
       new_highlight_line = $count - 1;
       cursor_pressed = 1;
@@ -626,6 +637,9 @@
     options_$_->{name}\[highlight_line+1\].draw( menu_left_edge_x, menu_width, options_$_->{name} + highlight_line + 1, &widget_options_settings );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/picture.c b/ui/widget/picture.c
index 0e59868..670cd50 100644
--- a/ui/widget/picture.c
+++ b/ui/widget/picture.c
@@ -49,12 +49,24 @@
     widget_picture_draw( ptr );
     break;
 #endif
-    
+#ifdef GCWZERO
+  case INPUT_KEY_Home:  /* Power   */
+  case INPUT_KEY_End:   /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_OK );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/pokefinder.c b/ui/widget/pokefinder.c
index 64d6efe..5154daa 100644
--- a/ui/widget/pokefinder.c
+++ b/ui/widget/pokefinder.c
@@ -163,10 +163,23 @@
 widget_pokefinder_keyhandler( input_key key )
 {
   switch ( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:	/* Close widget */
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Shift_L:
+#endif
   case INPUT_KEY_c:		/* Close widget */
     widget_end_all( WIDGET_FINISHED_OK );
     break;
@@ -183,6 +196,9 @@
     display_possible();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_KEY_s:		/* Search */
@@ -223,8 +239,13 @@
   case INPUT_KEY_Down:	scroll(   1 ); break;
   case INPUT_KEY_Left:	scroll(  -4 ); break;
   case INPUT_KEY_Right:	scroll(   4 ); break;
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:	    scroll( -20 ); break;
+  case INPUT_KEY_BackSpace: scroll(  20 ); break;
+#else
   case INPUT_KEY_Home:	scroll( -20 ); break;
   case INPUT_KEY_End:	scroll(  20 ); break;
+#endif
 
   /* Value alteration */
   case INPUT_KEY_0:
@@ -241,7 +262,11 @@
     display_value();
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_space:
+#else
   case INPUT_KEY_BackSpace:	/* Value alteration */
+#endif
     value /= 10;
     display_value();
     break;
diff --git a/ui/widget/pokemem.c b/ui/widget/pokemem.c
index 1f0be3d..e60e298 100644
--- a/ui/widget/pokemem.c
+++ b/ui/widget/pokemem.c
@@ -250,12 +250,25 @@
   new_selected = selected;
 
   switch ( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return: /* Do pokes */
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
     widget_end_all( WIDGET_FINISHED_OK );
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape: /* Close widget */
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
@@ -265,19 +278,35 @@
     if( !widget_pokemem_add_custom_poke() ) new_selected = pokemem_count - 1;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Up:
+#else
   case INPUT_KEY_Home:
+#endif
     new_selected = 0;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Page_Down:
+#else
   case INPUT_KEY_End:
+#endif
     new_selected = pokemem_count - 1;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Page_Up:
+#endif
     new_selected = ( selected > page_size )? selected - page_size : 0;
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_Page_Down:
+#endif
     new_selected = selected + page_size;
     if( new_selected >= pokemem_count ) new_selected = pokemem_count - 1;
     break;
diff --git a/ui/widget/query.c b/ui/widget/query.c
index c3f3d35..12ba646 100644
--- a/ui/widget/query.c
+++ b/ui/widget/query.c
@@ -232,7 +232,17 @@
     widget_general_show_all( &widget_options_settings );
     break;
 #endif
-    
+
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
@@ -256,6 +266,9 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
diff --git a/ui/widget/roms.c b/ui/widget/roms.c
index 70fd09d..d731408 100644
--- a/ui/widget/roms.c
+++ b/ui/widget/roms.c
@@ -47,7 +47,9 @@
   int i;
   char buffer[32];
   char key[] = "\x0A ";
-
+#if VKEYBOARD
+  vkeyboard_enabled = 1;
+#endif
   if( data ) info = data;
 
   /* Get a copy of the current settings */
@@ -116,10 +118,23 @@
     break;
 #endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
     widget_end_all( WIDGET_FINISHED_OK );
@@ -132,7 +147,9 @@
 
   if( key >= INPUT_KEY_a && key <= INPUT_KEY_z &&
       key - INPUT_KEY_a < (ptrdiff_t)rom_count ) {
-
+#if VKEYBOARD
+    vkeyboard_enabled = 0;
+#endif
     char **setting;
     char buf[32];
     widget_filesel_data data;
@@ -144,6 +161,9 @@
     data.exit_all_widgets = 0;
     data.title = buf;
     widget_do_fileselector( &data );
+#if VKEYBOARD
+    vkeyboard_enabled = 1;
+#endif
     if( !widget_filesel_name ) return;
 
     setting = settings_get_rom_setting( widget_settings, key + first_rom,
@@ -157,6 +177,9 @@
 int
 widget_roms_finish( widget_finish_state finished )
 {
+#if VKEYBOARD
+  vkeyboard_enabled = 0;
+#endif
   if( finished == WIDGET_FINISHED_OK ) {
     settings_copy( &settings_current, widget_settings );
   }
diff --git a/ui/widget/select.c b/ui/widget/select.c
index 1a88c56..c11cb16 100644
--- a/ui/widget/select.c
+++ b/ui/widget/select.c
@@ -123,11 +123,24 @@
     break;
 #endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L:
+#endif
   case INPUT_KEY_Escape:
   case INPUT_JOYSTICK_FIRE_2:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L:
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
   case INPUT_JOYSTICK_FIRE_1:
@@ -152,14 +165,22 @@
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Tab:
+#else
   case INPUT_KEY_Home:
+#endif
     if ( highlight_line ) {
       new_highlight_line = 0;
       cursor_pressed = 1;
     }
     break;
 
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace:
+#else
   case INPUT_KEY_End:
+#endif
     if ( highlight_line + 2 < (ptrdiff_t)count ) {
       new_highlight_line = (ptrdiff_t)count - 1;
       cursor_pressed = 1;
diff --git a/ui/widget/text.c b/ui/widget/text.c
index f16a218..89270a4 100644
--- a/ui/widget/text.c
+++ b/ui/widget/text.c
@@ -46,7 +46,9 @@
 widget_text_draw( void *data )
 {
   widget_text_t* text_data = data;
-
+#if VKEYBOARD
+  vkeyboard_enabled = 1;
+#endif
   if( data ) {
     title = text_data->title;
     allow = text_data->allow;
@@ -93,14 +95,29 @@
 {
   switch( key ) {
 
+#ifdef GCWZERO
+  case INPUT_KEY_Shift_L: /* Y */
+#endif
   case INPUT_KEY_BackSpace:	/* Backspace generates DEL which is Caps + 0 */
     delete_character(); widget_text_draw_text();
     return;
+#ifdef GCWZERO
+  case INPUT_KEY_Home:
+  case INPUT_KEY_End: /* RetroFW */
+    widget_end_all( WIDGET_FINISHED_CANCEL );
+    return;
+#endif
 
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
   case INPUT_KEY_Escape:
     widget_end_widget( WIDGET_FINISHED_CANCEL );
     return;
 
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#endif
   case INPUT_KEY_Return:
   case INPUT_KEY_KP_Enter:
     widget_end_widget( WIDGET_FINISHED_OK );
@@ -162,6 +179,9 @@
 int
 widget_text_finish( widget_finish_state finished )
 {
+#if VKEYBOARD
+  vkeyboard_enabled = 0;
+#endif
   if( finished == WIDGET_FINISHED_OK ) {
 
     widget_text_text =
@@ -172,6 +192,5 @@
     free( widget_text_text );
     widget_text_text = NULL;
   }
-
   return 0;
 }
diff --git a/ui/widget/vkeyboard.c b/ui/widget/vkeyboard.c
new file mode 100644
index 0000000..8592ce2
--- /dev/null
+++ b/ui/widget/vkeyboard.c
@@ -0,0 +1,396 @@
+/* binary.c: The binary load/save widgets
+   Copyright (c) 2020 Pedro Luis Rodríguez González
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   E-mail: pl.rguez@gmail.com
+
+ */
+
+#include <config.h>
+
+#ifdef VKEYBOARD
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "fuse.h"
+#include "utils.h"
+#include "ui/uidisplay.h"
+#include "ui/vkeyboard.h"
+#include "widget_internals.h"
+#include "keyboard.h"
+
+static int position = 1;
+static void widget_print_keyboard( void );
+static void widget_input_keyboard( input_key key );
+static void widget_release_keyboard( input_key key );
+static void widget_print_key( int row, int key, int active );
+static void widget_vkeyboard_input( keyboard_key_name spectrum_key, int press );
+static void widget_vkeyboard_options_input( input_key, int press );
+
+typedef struct keyboard_t {
+  const char *label;
+  keyboard_key_name spectrum_key;
+} keyboard_t;
+
+typedef struct keyboard_options_key {
+  const char *label;
+  input_key keyboard_key;
+} keyboard_options_t;
+
+static const keyboard_t vkeyboard[4][10] = {
+  { { "1", KEYBOARD_1 },     { "2", KEYBOARD_2 }, { "3", KEYBOARD_3 }, { "4", KEYBOARD_4 },       { "5", KEYBOARD_5 },
+    { "6", KEYBOARD_6 },     { "7", KEYBOARD_7 }, { "8", KEYBOARD_8 }, { "9", KEYBOARD_9 },       { "0", KEYBOARD_0 } },
+  { { "Q", KEYBOARD_q },     { "W", KEYBOARD_w }, { "E", KEYBOARD_e }, { "R", KEYBOARD_r },       { "T", KEYBOARD_t },
+    { "Y", KEYBOARD_y },     { "U", KEYBOARD_u }, { "I", KEYBOARD_i }, { "O", KEYBOARD_o },       { "P", KEYBOARD_p } },
+  { { "A", KEYBOARD_a },     { "S", KEYBOARD_s }, { "D", KEYBOARD_d }, { "F", KEYBOARD_f },       { "G", KEYBOARD_g },
+    { "H", KEYBOARD_h },     { "J", KEYBOARD_j }, { "K", KEYBOARD_k }, { "L", KEYBOARD_l },       { "En", KEYBOARD_Enter } },
+  { { "Cs", KEYBOARD_Caps }, { "Z", KEYBOARD_z }, { "X", KEYBOARD_x }, { "C", KEYBOARD_c },       { "V", KEYBOARD_v },
+    { "B", KEYBOARD_b },     { "N", KEYBOARD_n }, { "M", KEYBOARD_m }, { "Ss", KEYBOARD_Symbol }, { "Sp", KEYBOARD_space } },
+};
+
+static const keyboard_options_t vkeyboard_options[4][10] = {
+  { { "1", INPUT_KEY_1 },     { "2", INPUT_KEY_2 }, { "3", INPUT_KEY_3 },      { "4", INPUT_KEY_4 },      { "5", INPUT_KEY_5 },
+    { "6", INPUT_KEY_6 },     { "7", INPUT_KEY_7 }, { "8", INPUT_KEY_8 },      { "9", INPUT_KEY_9 },      { "0", INPUT_KEY_0 } },
+  { { "q", INPUT_KEY_q },     { "w", INPUT_KEY_w }, { "e", INPUT_KEY_e },      { "r", INPUT_KEY_r },      { "t", INPUT_KEY_t },
+    { "y", INPUT_KEY_y },     { "u", INPUT_KEY_u }, { "i", INPUT_KEY_i },      { "o", INPUT_KEY_o },      { "p", INPUT_KEY_p } },
+  { { "a", INPUT_KEY_a },     { "s", INPUT_KEY_s }, { "d", INPUT_KEY_d },      { "f", INPUT_KEY_f },      { "g", INPUT_KEY_g },
+    { "h", INPUT_KEY_h },     { "j", INPUT_KEY_j }, { "k", INPUT_KEY_k },      { "l", INPUT_KEY_l },      { "En", INPUT_KEY_Return } },
+  { { "z", INPUT_KEY_z },     { "x", INPUT_KEY_x }, { "c", INPUT_KEY_c },      { "v", INPUT_KEY_v },      { "b", INPUT_KEY_b },
+    { "n", INPUT_KEY_n },     { "m", INPUT_KEY_m }, { ".", INPUT_KEY_period }, { "-", INPUT_KEY_minus },  { "Sp", INPUT_KEY_space } },
+};
+
+static const keyboard_options_t vkeyboard_options_u[4][10] = {
+  { { "1", INPUT_KEY_1 },     { "2", INPUT_KEY_2 }, { "3", INPUT_KEY_3 },      { "4", INPUT_KEY_4 },      { "5", INPUT_KEY_5 },
+    { "6", INPUT_KEY_6 },     { "7", INPUT_KEY_7 }, { "8", INPUT_KEY_8 },      { "9", INPUT_KEY_9 },      { "0", INPUT_KEY_0 } },
+  { { "Q", INPUT_KEY_Q },     { "W", INPUT_KEY_W }, { "E", INPUT_KEY_E },      { "R", INPUT_KEY_R },      { "T", INPUT_KEY_T },
+    { "Y", INPUT_KEY_Y },     { "U", INPUT_KEY_U }, { "I", INPUT_KEY_I },      { "O", INPUT_KEY_O },      { "P", INPUT_KEY_P } },
+  { { "A", INPUT_KEY_A },     { "S", INPUT_KEY_S }, { "D", INPUT_KEY_D },      { "F", INPUT_KEY_F },      { "G", INPUT_KEY_G },
+    { "H", INPUT_KEY_H },     { "J", INPUT_KEY_J }, { "K", INPUT_KEY_K },      { "L", INPUT_KEY_L },      { "En", INPUT_KEY_Return } },
+  { { "Z", INPUT_KEY_Z },     { "X", INPUT_KEY_X }, { "C", INPUT_KEY_C },      { "V", INPUT_KEY_V },      { "b", INPUT_KEY_B },
+    { "N", INPUT_KEY_N },     { "M", INPUT_KEY_M }, { ",", INPUT_KEY_comma },  { "_", INPUT_KEY_underscore },  { "Sp", INPUT_KEY_space } },
+};
+
+static int fixed_keys_released[4][10] = {};
+static int fixed_keys[4][10] = {};
+static int one_time_fixed_keys[4][10] = {};
+static int actual_row = 0, actual_key = 0;
+static int press_row = 0, press_key = 0;
+static int keyboard_upper = 0;
+
+#define LOCK_KEY                  1 /* Blue bright 0 */
+#define FIXED_KEY                 2 /* Red bright 0 */
+#define SELECTED_KEY              5 /* Cyan bright 0 */
+#define NOT_SELECTED_KEY         16 /* Alpha value not selected Key */
+#define NOT_SELECTED_KEY_OPTIONS 15 /* White brigth 1 */
+#define INK_KEY                  15 /* White bright 1 */
+#define INK_KEY_OPTIONS           0 /* Black bright 0 */
+
+void widget_print_key( int row, int key, int active )
+{
+  int paper, ink, x, y;
+
+  if ( one_time_fixed_keys[row][key] )
+    paper = LOCK_KEY;
+  else if ( fixed_keys[row][key] )
+    paper = FIXED_KEY;
+  else if ( active )
+    paper = SELECTED_KEY;
+  else if ( ui_widget_level >= 0 )
+    paper = NOT_SELECTED_KEY_OPTIONS;
+  else
+    paper = NOT_SELECTED_KEY;
+  ink = (ui_widget_level >= 0) ? INK_KEY_OPTIONS : INK_KEY;
+  x = key * 16 + 5;
+  y = row * 10 + 5;
+
+  widget_rectangle(x, y, 16, 10, paper);
+  widget_printstring(x + 2, y + 1, ink,
+                     (ui_widget_level >= 0)
+                       ? (keyboard_upper) ? vkeyboard_options_u[row][key].label
+                                          : vkeyboard_options[row][key].label
+                       : vkeyboard[row][key].label);
+}
+
+void
+widget_print_keyboard( void )
+{
+  int row, key;
+  for (row = 0; row < 4; row++) {
+    for (key = 0; key < 10; key++) {
+      widget_print_key(row, key, ( actual_row == row && actual_key == key ));
+    }
+  }
+}
+
+void
+widget_vkeyboard_input( keyboard_key_name spectrum_key, int press ) {
+  if (press)
+    keyboard_press(spectrum_key);
+  else
+    keyboard_release(spectrum_key);
+}
+
+void
+widget_vkeyboard_options_input( input_key key, int press ) {
+  if (press) {
+    switch (key) {
+    case INPUT_KEY_Return:
+      widget_vkeyboard_finish( WIDGET_FINISHED_OK );
+      break;
+    default:
+      break;
+    }
+
+    ui_widget_keyhandler( key );
+  }
+}
+
+void
+widget_input_keyboard( input_key key )
+{
+  int r, k;
+
+  switch ( key ) {
+#if 0
+  case INPUT_KEY_Resize:	/* Fake keypress used on window resize */
+    widget_menu_draw( menu );
+    break;
+#endif
+
+#ifdef GCWZERO
+  case INPUT_KEY_Return: /* Start */
+#else
+  case INPUT_KEY_Escape:
+  case INPUT_KEY_F11:
+  case INPUT_JOYSTICK_FIRE_2:
+#endif
+    widget_vkeyboard_finish( WIDGET_FINISHED_CANCEL );
+    if (ui_widget_level >= 0)
+      widget_end_widget( WIDGET_FINISHED_CANCEL );
+    return;
+
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#else
+  case INPUT_KEY_Return:
+#endif
+    press_row = actual_row;
+    press_key = actual_key;
+    if (ui_widget_level >= 0) {
+      input_key pressed_key = keyboard_upper ? vkeyboard_options_u[actual_row][actual_key].keyboard_key
+                                             : vkeyboard_options[actual_row][actual_key].keyboard_key;
+      widget_vkeyboard_options_input( pressed_key,1);
+      return;
+    } else {
+      for (r = 0; r < 4; r++)
+        for (k = 0; k < 10; k++)
+          if (one_time_fixed_keys[r][k]) {
+            widget_vkeyboard_input(vkeyboard[r][k].spectrum_key,1);
+          }
+      widget_vkeyboard_input(vkeyboard[actual_row][actual_key].spectrum_key,1);
+    }
+    break;
+
+#ifdef GCWZERO
+  case INPUT_KEY_Alt_L: /* B */
+#endif
+  case INPUT_KEY_Control_R:
+    if (ui_widget_level >= 0) {
+      widget_vkeyboard_finish( WIDGET_FINISHED_CANCEL );
+      widget_vkeyboard_options_input( INPUT_KEY_Escape, 1 );
+      return;
+    } else {
+      one_time_fixed_keys[actual_row][actual_key] = one_time_fixed_keys[actual_row][actual_key] ? 0 : 1;
+      if (fixed_keys[actual_row][actual_key]) {
+        fixed_keys_released[actual_row][actual_key] = 1;
+        fixed_keys[actual_row][actual_key] = 0;
+      }
+    }
+    break;
+
+#ifdef GCWZERO
+  case INPUT_KEY_space: /* X */
+#endif
+  case INPUT_KEY_Shift_R:
+    if (ui_widget_level >= 0) {
+      keyboard_upper = !keyboard_upper;
+    } else {
+      fixed_keys_released[actual_row][actual_key] = fixed_keys[actual_row][actual_key] ? 1 : 0;
+      fixed_keys[actual_row][actual_key] = fixed_keys[actual_row][actual_key] ? 0 : 1;
+      one_time_fixed_keys[actual_row][actual_key] = 0;
+    }
+    break;
+
+#ifdef GCWZERO
+  case INPUT_KEY_Shift_L: /* Y */
+#else
+  case INPUT_KEY_BackSpace:
+#endif
+  case INPUT_KEY_Alt_R:
+    if (ui_widget_level >= 0) {
+      widget_vkeyboard_options_input( INPUT_KEY_BackSpace, 1 );
+    } else {
+      for (r=0;r<4;r++)
+        for(k=0;k<10;k++) {
+          if (one_time_fixed_keys[r][k])
+            one_time_fixed_keys[r][k] = 0;
+          if (fixed_keys[r][k]) {
+            fixed_keys[r][k] = 0;
+            fixed_keys_released[r][k] = 0;
+            widget_vkeyboard_input(vkeyboard[r][k].spectrum_key,0);
+          }
+        }
+    }
+    break;
+
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace: /* L1 */
+#else
+  case INPUT_KEY_Page_Up:
+#endif
+    if (ui_widget_level >= 0) {
+      widget_vkeyboard_options_input( INPUT_KEY_BackSpace, 1 );
+    } else {
+      position++;
+      if ( position == 4 )
+        position = 0;
+    }
+    break;
+
+#ifdef GCWZERO
+  case INPUT_KEY_Tab: /* R1 */
+#else
+  case INPUT_KEY_Page_Down:
+#endif
+    if (ui_widget_level >= 0) {
+      widget_vkeyboard_options_input( INPUT_KEY_BackSpace, 1 );
+    } else {
+      if ( position == 0 )
+        position = 3;
+      else
+        position--;
+    }
+    break;
+
+  case INPUT_KEY_Up:
+    (actual_row == 0) ? actual_row = 3 : actual_row--;
+    break;
+
+  case INPUT_KEY_Down:
+    (actual_row == 3) ? actual_row = 0 : actual_row++;
+    break;
+
+  case INPUT_KEY_Left:
+    (actual_key == 0) ? actual_key = 9 : actual_key--;
+    break;
+
+  case INPUT_KEY_Right:
+    (actual_key == 9) ? actual_key = 0 : actual_key++;
+    break;
+
+  default:
+    if (ui_widget_level >= 0)
+      widget_vkeyboard_input( key, 1 );
+    break;
+  }
+
+  if (ui_widget_level >= 0) {
+    widget_display_rasters( DISPLAY_BORDER_HEIGHT * -1, DISPLAY_SCREEN_HEIGHT );
+  } else {
+    for (r=0;r<4;r++)
+      for(k=0;k<10;k++) {
+        if (fixed_keys_released[r][k]) {
+          widget_vkeyboard_input(vkeyboard[r][k].spectrum_key,0);
+          fixed_keys_released[r][k] = 0;
+        }
+        if (fixed_keys[r][k])
+          widget_vkeyboard_input(vkeyboard[r][k].spectrum_key,1);
+      }
+  }
+}
+
+void
+widget_release_keyboard( input_key key )
+{
+  int r, k;
+
+  switch ( key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Control_L: /* A */
+#else
+  case INPUT_KEY_Return:
+#endif
+    press_row = 0;
+    press_key = 0;
+    if (ui_widget_level >= 0) {
+      input_key pressed_key = keyboard_upper ? vkeyboard_options_u[actual_row][actual_key].keyboard_key
+                                             : vkeyboard_options[actual_row][actual_key].keyboard_key;
+      widget_vkeyboard_options_input(pressed_key,0);
+    } else {
+      for (r = 0; r < 4; r++)
+        for (k = 0; k < 10; k++)
+          if (one_time_fixed_keys[r][k]) {
+            widget_vkeyboard_input(vkeyboard[r][k].spectrum_key,0);
+            one_time_fixed_keys[r][k] = 0;
+            widget_print_key(r,k,0);
+          }
+      widget_vkeyboard_input(vkeyboard[actual_row][actual_key].spectrum_key,0);
+    }
+    return;
+
+  default:
+    break;
+  }
+}
+
+int
+widget_vkeyboard_draw( void *data )
+{
+  uidisplay_vkeyboard( &widget_print_keyboard, position );
+  return 0;
+}
+
+void
+widget_vkeyboard_keyhandler( input_key key )
+{
+  uidisplay_vkeyboard_input( &widget_input_keyboard, key );;
+}
+
+void
+widget_vkeyboard_keyrelease( input_key key )
+{
+  uidisplay_vkeyboard_release( &widget_release_keyboard, key );;
+}
+
+int
+widget_vkeyboard_finish( widget_finish_state finished )
+{
+  int r, k;
+  for (r=0;r<4;r++)
+    for(k=0;k<10;k++) {
+      if (fixed_keys[r][k])
+        keyboard_release(vkeyboard[r][k].spectrum_key);
+      fixed_keys_released[r][k] = 0;
+      fixed_keys[r][k] = 0;
+      one_time_fixed_keys[r][k] = 0;
+    }
+  vkeyboard_enabled = 0;
+  return 0;
+}
+#endif /* VKEYBOARD */
\ No newline at end of file
diff --git a/ui/widget/widget.c b/ui/widget/widget.c
index 61564c0..f655d3b 100644
--- a/ui/widget/widget.c
+++ b/ui/widget/widget.c
@@ -51,10 +51,16 @@
 #include "ui/widget/options_internals.h"
 #include "ui/widget/widget_internals.h"
 #include "utils.h"
+#ifdef VKEYBOARD
+#include "ui/vkeyboard.h"
+#endif
 
 #ifdef WIN32
 #include <windows.h>
 #endif
+#ifdef VKEYBOARD
+int vkeyboard_enabled = 0;
+#endif
 
 /* Bitmap font storage */
 typedef struct {
@@ -265,6 +271,24 @@
   widget_printstring( 128 - widget_stringwidth( buffer ) / 2, y, col, buffer );
 }
 
+#ifdef GCWZERO
+void widget_print_filetitle( int y, struct widget_dirent *current, int is_saving )
+{
+  char buffer[128];
+  char *name, *old_name;
+
+  widget_rectangle( 10, y, 236, 8, WIDGET_COLOUR_BACKGROUND );
+  if (is_saving || S_ISDIR(current->mode) ) return;
+  name = strdup( current->name );
+  if (!name) return;
+  old_name = name;
+  while( widget_stringwidth( name ) > 232 ) name++;
+  snprintf( buffer, sizeof( buffer ), "\x0A%s", name );
+  free(old_name);
+  widget_printstring( 128 - widget_stringwidth( buffer ) / 2, y, WIDGET_COLOUR_FOREGROUND, buffer );
+}
+#endif
+
 void widget_printstring_right( int x, int y, int col, const char *s )
 {
   widget_printstring( x - widget_stringwidth( s ), y, col, s );
@@ -487,6 +511,49 @@
   return 0;
 }
 
+#ifdef GCWZERO
+#define WIDGET_MAX_INFO_LENGTH 40
+#define WIDGET_COL_INFO 5
+#define WIDGET_ROW_INFO 225
+#define WIDGET_RELATIVE_COL_INFO (WIDGET_COL_INFO - DISPLAY_BORDER_ASPECT_WIDTH)
+#define WIDGET_RELATIVE_ROW_INFO (WIDGET_ROW_INFO - DISPLAY_BORDER_HEIGHT)
+static char status_info[WIDGET_MAX_INFO_LENGTH];
+static int  info_len = 0;
+static int  info_sc  = 1;
+void widget_statusbar_update_info( float speed ) {
+/*
+  snprintf(status_info, WIDGET_MAX_INFO_LENGTH, "%s - %3.0f%% (1:%d)",
+           libspectrum_machine_name( machine_current->machine ),
+           speed,
+           settings_current.frame_rate);
+*/
+  snprintf(status_info, WIDGET_MAX_INFO_LENGTH, "%s - %3.0ffps (1:%d)",
+           libspectrum_machine_name( machine_current->machine ),
+           speed,
+           settings_current.frame_rate);
+  if ( settings_current.triple_buffer )
+    snprintf(status_info, WIDGET_MAX_INFO_LENGTH, "%s [%s]",
+             status_info,
+             "B");
+}
+
+void widget_statusbar_print_info(void) {
+  int sc = machine_current->capabilities & LIBSPECTRUM_MACHINE_CAPABILITY_TIMEX_VIDEO ? 2 : 1;
+  int len = widget_stringwidth(status_info);
+  if (len>0) {
+    if (info_len && len < info_len) {
+      widget_rectangle(WIDGET_RELATIVE_COL_INFO, WIDGET_RELATIVE_ROW_INFO, info_len, 8, WIDGET_COLOUR_DISABLED);
+      uidisplay_area(WIDGET_COL_INFO*info_sc, WIDGET_ROW_INFO*info_sc, info_len*info_sc, 8 * info_sc);
+    }
+    info_len = len;
+    info_sc = sc;
+    widget_rectangle(WIDGET_RELATIVE_COL_INFO, WIDGET_RELATIVE_ROW_INFO, info_len, 8, 5);
+    widget_printstring(WIDGET_RELATIVE_COL_INFO, WIDGET_RELATIVE_ROW_INFO, 10, status_info);
+    uidisplay_area(WIDGET_COL_INFO*info_sc, WIDGET_ROW_INFO*info_sc, info_len*info_sc, 8*info_sc);
+  }
+}
+#endif
+
 /* General widget routine */
 
 int widget_do( widget_type which, void *data )
@@ -559,6 +626,21 @@
   return 0;
 }
 
+#ifdef GCWZERO
+/* End the currently running widget */
+int widgets_to_end = 0;
+int
+widget_end_n_widgets( int number, widget_finish_state state )
+{
+  int i;
+
+  for( i=ui_widget_level; i > ui_widget_level - number; i-- )
+    widget_return[i].finished = state;
+
+  return 0;
+}
+#endif
+
 /* End the currently running widget */
 int
 widget_end_widget( widget_finish_state state )
@@ -692,6 +774,9 @@
   { widget_query_save_draw,widget_query_finish,	 widget_query_save_keyhandler },
   { widget_diskoptions_draw, widget_options_finish, widget_diskoptions_keyhandler  },
   { widget_binary_draw, widget_binary_finish, widget_binary_keyhandler  },
+#ifdef VKEYBOARD
+  { widget_vkeyboard_draw, widget_vkeyboard_finish, widget_vkeyboard_keyhandler  },
+#endif
 };
 
 #ifndef UI_SDL
@@ -780,6 +865,11 @@
 ui_popup_menu( int native_key )
 {
   switch( native_key ) {
+#ifdef GCWZERO
+  case INPUT_KEY_Home: /* Power Button GCW0/RG350 */
+  case INPUT_KEY_End: /* Power Button RetroFW */
+  case INPUT_KEY_Escape: /* Select */
+#endif
   case INPUT_KEY_F1:
     fuse_emulation_pause();
     widget_do_menu( widget_menu );
@@ -790,11 +880,17 @@
     menu_file_savesnapshot( 0 );
     fuse_emulation_unpause();
     break;
+#ifdef GCWZERO
+  case INPUT_KEY_Tab: /*L1*/
+#endif
   case INPUT_KEY_F3:
     fuse_emulation_pause();
     menu_file_open( 0 );
     fuse_emulation_unpause();
     break;
+#ifdef GCWZERO
+  case INPUT_KEY_BackSpace: /*R1*/
+#endif
   case INPUT_KEY_F4:
     fuse_emulation_pause();
     menu_options_general( 0 );
@@ -828,6 +924,17 @@
     menu_file_exit( 0 );
     fuse_emulation_unpause();
     break;
+#ifdef VKEYBOARD
+#ifdef GCWZERO
+  case INPUT_KEY_Return: /*Start*/
+#endif
+  case INPUT_KEY_F11:
+    vkeyboard_enabled = !vkeyboard_enabled;
+/*
+    menu_vkeyboard( 0 );
+*/
+    break;
+#endif /* VKEYBOARD */
 
   default: break;		/* Remove gcc warning */
 
diff --git a/ui/widget/widget.h b/ui/widget/widget.h
index 861e598..909d2ff 100644
--- a/ui/widget/widget.h
+++ b/ui/widget/widget.h
@@ -32,6 +32,21 @@
 /* Code called at start and end of emulation */
 int widget_init( void );
 int widget_end( void );
+#ifdef GCWZERO
+void widget_statusbar_update_info( float speed );
+void widget_statusbar_print_info( void );
+#endif
+
+#ifdef VKEYBOARD
+/*
+ See widgent_internals.h for other widget virtual keyboard functions.
+ The function defined here are to avoid implicit definition at calls in
+ ui.c functions.
+*/
+int widget_vkeyboard_draw( void *data );
+void widget_vkeyboard_keyhandler( input_key key );
+void widget_vkeyboard_keyrelease( input_key key );
+#endif
 
 /* The various widgets which are available */
 typedef enum widget_type {
@@ -61,6 +76,9 @@
   WIDGET_TYPE_QUERY_SAVE,	/* Query (save/don't save/cancel) */
   WIDGET_TYPE_DISKOPTIONS,	/* Disk options widget */
   WIDGET_TYPE_BINARY,		/* Binary load/save */
+#ifdef VKEYBOARD
+  WIDGET_TYPE_VKEYBOARD,	/* Virtual Keyboard */
+#endif
 } widget_type;
 
 /* Activate a widget */
@@ -154,6 +172,14 @@
   return widget_do( WIDGET_TYPE_ABOUT, NULL );
 }
 
+#ifdef VKEYBOARD
+/* Virtual Keyboard widget */
+static inline int widget_do_vkeyboard( void )
+{
+  return widget_do( WIDGET_TYPE_VKEYBOARD, NULL );
+}
+#endif
+
 /* General menu */
 static inline int widget_do_menu( widget_menu_entry *data )
 {
diff --git a/ui/widget/widget_internals.h b/ui/widget/widget_internals.h
index 7d50586..b4d4ccc 100644
--- a/ui/widget/widget_internals.h
+++ b/ui/widget/widget_internals.h
@@ -56,6 +56,13 @@
   widget_keyhandler_fn keyhandler;	/* Keyhandler */
 } widget_t;
 
+#ifdef GCWZERO
+/* At joystick configurations when accept a key we don't want to exit
+  completely the widgets. We want return to the configuration of other keys. */
+extern int widgets_to_end;
+int
+widget_end_n_widgets( int number, widget_finish_state state );
+#endif
 int widget_end_widget( widget_finish_state state );
 int widget_end_all( widget_finish_state state );
 
@@ -271,8 +278,27 @@
 void widget_binary_keyhandler( input_key key );
 int widget_binary_finish( widget_finish_state finished );
 
+#ifdef VKEYBOARD
+/*
+ Virtual Keyboard functions are not used as normal widget launched from
+ popup menu.
+
+ widget_vkeyboard_finish is defined here to make possible use the type
+ widget_finish_state.
+
+ See widget.h for the definition of other functions for vkeyboard:
+      widget_vkeyboard_draw
+      widget_vkeyboard_keyhandler
+      widget_vkeyboard_keyrelease
+*/
+int widget_vkeyboard_finish( widget_finish_state finished );
+#endif
 /* The widgets actually available */
 
 extern widget_t widget_data[];
 
+#ifdef GCWZERO
+void widget_print_filetitle( int y, struct widget_dirent *current, int is_saving );
+#endif
+
 #endif				/* #ifndef FUSE_WIDGET_INTERNALS_H */
diff --git a/utils.c b/utils.c
index 13c97fb..51b9caa 100644
--- a/utils.c
+++ b/utils.c
@@ -58,6 +58,10 @@
 #include "tape.h"
 #include "utils.h"
 
+#ifdef GCWZERO
+char* last_filename = NULL;
+#endif
+
 static void init_path_context( path_context *ctx, utils_aux_type type );
 
 static int networking_init_count = 0;
@@ -494,3 +498,31 @@
 #endif
 }
 
+#ifdef GCWZERO
+char* utils_last_filename( const char *filename )
+{
+  char *c, *test_file, *last_file;
+
+  if( !strlen( filename ) ) return NULL; /* Nothing to search */
+
+  test_file = utils_safe_strdup( filename );
+  if( !test_file ) return NULL; /* Nothing to search */
+
+  c = strrchr( test_file, FUSE_DIR_SEP_CHR );
+  if (c)
+    last_file = utils_safe_strdup( ++c );
+  else
+    last_file = utils_safe_strdup( test_file );
+
+  /* Search for extension */
+  c = strrchr( last_file, '.' );
+  if( c ) {
+    int n = c - last_file;
+    last_file[n] = '\0';
+  }
+
+  libspectrum_free( test_file );
+
+  return last_file;
+}
+#endif
diff --git a/utils.h b/utils.h
index aa482c4..82621d6 100644
--- a/utils.h
+++ b/utils.h
@@ -35,6 +35,11 @@
 
 } utils_file;
 
+#ifdef GCWZERO
+/* Last filename loaded */
+extern char* last_filename;
+#endif
+
 int utils_open_file( const char *filename, int autoload,
 		     libspectrum_id_t *type );
 int utils_open_snap( void );
@@ -62,4 +67,8 @@
 void utils_networking_init( void );
 void utils_networking_end( void );
 
+#ifdef GCWZERO
+char* utils_last_filename( const char *filename );
+#endif
+
 #endif			/* #ifndef FUSE_UTILS_H */
